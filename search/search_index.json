{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#architecture","title":"Architecture","text":""},{"location":"glossary/","title":"A","text":""},{"location":"glossary/#c","title":"C","text":"<p>CaaM CaaM OS</p>"},{"location":"glossary/#d","title":"D","text":""},{"location":"glossary/#e","title":"E","text":"<p>ESP Embever Cloud Embever IoT Core Embever IoT Core Cloud </p>"},{"location":"glossary/#u","title":"U","text":"<p>User Application Framework</p> <p>ESP CaaM OS - What is CaaM OS ?</p> <p>Define Embever IoT Core </p>"},{"location":"cloud/","title":"Embever Cloud","text":"<p>Embever Cloud is a cloud infrastructure that is specifically designed to support and facilitate the connection, management and data processing of Internet of Things (IoT) devices. Different services run in embever cloud to connect and transfer data from the IoT devices to the end user application. Embever cloud provides a secure way to transfer to and from the IoT devices to the user applications.</p>"},{"location":"cloud/#secure-connection-to-mobile-network-operators-mnos","title":"Secure Connection to Mobile Network Operators (MNOs)","text":"<p>When the devices connect to the embever cloud the connection is securely tunneled from the Mobile network perators to the embever cloud. Embever cloud maintains the infrastructure for the secure conection using industry standard secure tunnels. All the devices are in a virtual private network and cannot be accessed from the public internet. This provides one layer of security for the secure transfer of data from the devices coming from the MNOs to the Embever Cloud. On top of that Embever Cloud also makes sure that the data coming from the device is actually from the specific device and not from anyother source.</p>"},{"location":"cloud/#running-embever-cloud-on-premise","title":"Running Embever Cloud on Premise","text":"<p>All the services that run on the embever cloud are independent of any vendors and the whole cloud infrastructure can run on any cloud service provider as well as on premise itself. This provides customers with long term stability among many advantages to the customers using the Embever cloud for their IoT projects/applications.  If any customer wishes to run Embever Cloud on their own an their choice of vendor or even on permise, customer can buy the license for the Embever cloud to do that. Embever will help on the smooth transiton or make sure the customer has a fully functioning Embever cloud on their own.</p>"},{"location":"cloud/api/","title":"REST API","text":""},{"location":"cloud/api/#overview","title":"Overview","text":""},{"location":"cloud/api/#about","title":"About","text":"<p>You can use Embever cloud API to manage your resources in embever cloud as well as interact with your devices.</p>"},{"location":"cloud/api/#registrating-on-the-api","title":"Registrating on the API","text":"<p>For each organisation or user who uses Cloud as a Moudule, Embever creates creates a primary admin account to access the console and api of the Embever cloud. The primary admin user can create and manage the accounts and roles via the console or from the api.</p> <p>Note</p> <p>There is no public registration for the user in Embever Cloud. A primary admin user of your organisation can create an account for you to use the Embever Cloud.</p>"},{"location":"cloud/api/#api-versions","title":"API Versions","text":"<p>The Embever Cloud REST API is versioned. To maintain the compatibility with the changes in the API, the API has different versions. Any breaking chages will be released in a new version. Any non breaking chages and fixes shall be applied to the existing version itself. When the new API version is released the older versions will still be supported. The versoning is incorporated in the base URL. The API versoning follows the following format</p> <p><code>https://baseurl/&lt;version&gt;/path</code></p> <p>An example of the request URL with an API version is <code>https://api.embever.com/v2/devices</code></p> <p>Note</p> <p>Version v1 is deprecated and no longer supported. The current api version is v2.</p>"},{"location":"cloud/api/#supported-api-versions","title":"Supported API Versions","text":"<p>The following REST API versions are currently supported</p> <ul> <li>v2</li> </ul>"},{"location":"cloud/api/#browsable-api","title":"Browsable API","text":"<p>Embever cloud features a browsable api which facilitates the interaction with the REST API through any web browser. You can make API requests and surf through the API using the browsable API. The browsable api is available under the base url of the api <code>https://api.embever.com/</code>. </p>"},{"location":"cloud/api/#using-the-api","title":"Using the API","text":"<p>Note</p> <p>This document assumes that you have the basic idea on REST API requests and its elements.</p> <p>Any request you make to the REST API includes an HTTP method and a path. You might need to include specific request headers, authenticaiton information, query parameters or body parameters depending on the API endpoints. For more detailed information see the REST API reference document.</p> <pre><code>how to make the request, tokens...\n</code></pre>"},{"location":"cloud/api/#authentication","title":"Authentication","text":"<p>Many endpoints on the REST API require authentication. The API uses JWT tokens to authorize requests to ressources. Your application can obtain an access token by posting an application token to the /authenticate endpoint (for creatinng application tokens refer to Tokens). The access token is used for the requests to the API, but has a short validity period. When it expires, the application token must be used again to gain a new auth token. The access token is passed in the request\u2019s Authorization header.</p>"},{"location":"cloud/api/#geting-the-application-token","title":"Geting the application token","text":"<p>Note</p> <p>This application should be kept seceretly. We recommend the application token to have an expiry date and change the application token time to time.</p>"},{"location":"cloud/api/#getting-the-access-and-refresh-token","title":"Getting the access and refresh token","text":""},{"location":"cloud/api/#using-the-access-token","title":"Using the access token","text":""},{"location":"cloud/api/#using-the-refresh-token","title":"Using the refresh token","text":""},{"location":"cloud/api/#pagination","title":"Pagination","text":"<p>When the response on REST API endpoints returns multiple items, it will be paginated to 100 items by default. For example <code>GET /devices/</code> will return only the first 100 devices even if there are 1700 devices. The api offers a way to easily navigate through the items using the <code>link</code> header. The <code>link</code> header from the response can be used to request additional pages of data.</p>"},{"location":"cloud/api/#using-link-headers","title":"Using <code>link</code> headers","text":"<p>When a response to the endpoint is paginated, the response headers will include a <code>link</code> header. If the endpoint does not support pagination, or if all results fit on a single page, the <code>link</code> header will be omitted. The <code>link</code> header contains url to fetch previous and the next page when applicable. For example you can use curl with <code>--include</code> flag to see the response headers.</p> <pre><code>curl --include --request GET \\\n--url \"https://api.embever.com/v2/devices/\"\n</code></pre> <p>If the response is paginated the <code>link</code> header will look something like this</p> <pre><code>link: \n &lt;https://api.embever.com/v2/devices/?cursor=cj0xJnA9MjAyMi0wOS0yMiswNiUzQTE1JTNBMzUuMDc0MjIyJTJCMDAlM0EwMA%3D%3D&gt;; rel=\"prev\", \n &lt;https://api.embever.com/v2/devices/?cursor=cD0yMDIyLTA5LTIyKzA2JTNBMTElM0EwMi41NjkzNzQlMkIwMCUzQTAw&gt;; rel=\"next\"\n</code></pre> <ul> <li>The URL for the previous page is followed by rel=\"prev\".</li> <li>The URL for the next page is followed by rel=\"next\".</li> </ul> <p>The link to the previous page won't be included if you are on the first page of the result. Likewise, the link to the next page won't be included if you are onn the last page of the result. The URL in the link header use query parameter to navigate to the another page of results.</p>"},{"location":"cloud/api/#guides","title":"Guides","text":""},{"location":"cloud/api/#creating-action","title":"Creating Action","text":""},{"location":"cloud/api/#sending-data-to-external-application","title":"Sending data to External Application","text":"<pre><code>.... using webhooks...\n</code></pre>"},{"location":"cloud/api/#deploying-the-frimware-to-devices","title":"Deploying the frimware to Devices","text":""},{"location":"cloud/api/#activatingdeactivating-the-device","title":"Activating/Deactivating the Device","text":""},{"location":"cloud/api/#sending-file-to-the-device","title":"Sending File to the Device","text":""},{"location":"cloud/api/#receiving-a-file-from-a-device","title":"Receiving a file from a Device","text":""},{"location":"cloud/api_reference/","title":"Api reference","text":""},{"location":"cloud/console/","title":"Embever Console","text":"<p>Embever console is the web based interface that allows users to interact and manage their resources in Embever cloud. Using the embever console the user can manage accounts, organisatoin details and also manage integration with exteranal systems. It is reachable under this link https://console.embever.com.</p>"},{"location":"cloud/console/#creating-an-account-on-embever-console","title":"Creating an Account on Embever Console","text":"<p>It's important to note that there is no provision for public signup within the Embever Console. Account creation is exclusively managed by administrative users of Embever and owners and admins of the organisation, ensuring controlled access to the platform's resources. Below are the steps involved in this process.</p> <ol> <li>Organisation creation<ul> <li>An organisation is created by the Administrative user of Embever. This step involves adding essential organisatinal details to the organisation.</li> </ul> </li> <li>Owner Account Setup<ul> <li>An owner account is setup by the Administrative user of Embever with the given email address from the related organisation.</li> </ul> </li> <li>Email Activation for Owner Account<ul> <li>An activation email is sent to the owner's email</li> </ul> </li> <li>Owner Account Activation<ul> <li>After the owner confirms their account activation, the owner gains access to the console.</li> </ul> </li> <li>User Account Creation by Owner<ul> <li>The owner can now create additional user accounts for the individuals within the organisation.</li> <li>The owner can assign admin or a normal user role to the accounts. See User Roles for more detail information on roles in Embever console.</li> </ul> </li> </ol>"},{"location":"cloud/console/#login-and-logout-to-the-console","title":"Login and Logout to the Console","text":""},{"location":"cloud/console/#login","title":"Login","text":"<p>To access the Embever Console, visit console.embever.com and enter your credentials (username and password) in the provided fields. Click on the \"Sign In\" button to authenticate your account. Upon succesful authentication you will be redirected to the homepage.</p>"},{"location":"cloud/console/#logout","title":"Logout","text":"<p>To log out of your Embever Console account, simply click on the \"Logout\" button which looks like a switch button located in the top-right part of the dashboard. This action will terminate your session and return you to the login screen.</p> <p>Recommendation</p> <p>It is always a best practice to always log out after you finish your work.</p>"},{"location":"cloud/console/#forgot-password","title":"Forgot Password","text":"<p>If you forget your password and are unable to log in, the Embever Console provides a simple and secure process to reset it. Follow the following steps to reset your password.</p> <ol> <li>Forgot Password Link: On the login page, locate and click on the \"Forgot Password\" link below the login form. You will be redirected to a another page.</li> <li>Email Verification: Enter the username and email address associated with your Embever IoT Core account and click on submit.</li> <li>Reset Link: You will receive an email containing a reset link to the provided email address. The link is valid only for 7 days.</li> <li>Password Reset: Click on the reset link in the email to navigate to the password reset page.</li> <li>New Password: Enter your username and set a new password for your account.</li> <li>Login: Once your password is successfully reset, you would be logged in and redirected to the home page of the console.</li> </ol> <p>This process ensures that even if you forget your password, you can regain access to your account securely and efficiently. If you encounter any issues during the password reset process, please don't hesitate to contact us for assistance.</p>"},{"location":"cloud/console/#organisation-details","title":"Organisation Details","text":"<p>Organisation Details are first added by the Administrative users of Embever as provided by the respective organisation. It mainly contains the informatin of the Organisation like name and contact information.</p>"},{"location":"cloud/console/#edit-organisation-details","title":"Edit Organisation Details","text":"<p>A user with the owner role of the organisation can change their organisation details. Organisational users with other roles (admin and normal users) will be only be able to see the details but not edit it. To change the organisation details follow the following steps.</p> <ol> <li>Login to the console.</li> <li>On the top right corner of the home screen click on the organisation icon. This will open a page with the organisation details.</li> <li>Edit your organisation details.</li> <li>Click on the submit button. If there are any errors please correct them and submit it.</li> <li>After the details are save successfully you will see edit successfull message on the top of the form itself.</li> </ol>"},{"location":"cloud/console/#accounts-management","title":"Accounts Management","text":"<p>Embever IoT Core offers different user roles, each with specific permissions to manage resources effectively.</p>"},{"location":"cloud/console/#user-roles","title":"User Roles","text":"<p>The users are primarily categorized into two groups.</p> <ol> <li> <p>Administrative users</p> <p>Administrative users are responsible or managing the Embever Console and the resources. These users are further categorized into two roles.</p> <ol> <li> <p>Superuser: Has full control over all aspects of the Embever Console, including user management and resource allocation.</p> </li> <li> <p>Staff User: Assigned to users for specific administrative tasks by superusers.</p> </li> </ol> </li> <li> <p>Organization Users</p> <p>Organization users are individuals associated with a particular organization and are typically assigned specific roles and permissions within the system. The organisational users are categorized further into three roles.</p> <ol> <li> <p>Owner: Has the highest level of authority within the organization. Can perform administrative tasks and manage other users.</p> </li> <li> <p>Admin User: Granted administrative privileges within the organization, such as user management and resource allocation.</p> </li> <li> <p>Normal User: Has limited permissions, typically restricted to accessing and interacting with assigned resources.</p> </li> </ol> </li> </ol> <p>Note</p> <p>There are additional user types specifically for API which doesnot have accounts for logging into the console. They are called organisation user and applicaiton user. Organisation user and application user are created automatically when an organisation or an application is created. These are created to provide scope on the organisational level and applicaiton for api requests. </p>"},{"location":"cloud/console/#owner-user","title":"Owner User","text":"<p>Owners possess the highest level of control and can perform the following administrative actions.</p> <ol> <li> <p>Assign Another Owner: Owners can designate another user as an owner of the organization.</p> </li> <li> <p>Create Users: Owners can create new users within the organization.</p> </li> <li> <p>Edit Users: Owners can modify user details and roles.</p> </li> <li> <p>Delete Users: Owners cannot directly delete users. Contact support@embever.com for user deletion requests. However, owners can deactivate the users, the deactivated users are no longer able to login and use the console.</p> </li> </ol>"},{"location":"cloud/console/#admin-user","title":"Admin User","text":"<p>Admin users have the second highest level of authority and can perform the following administrative actions.</p> <ol> <li> <p>Create Users: Admin users can create new users within the organization.</p> </li> <li> <p>Edit Users: Admin user can modify normal user details and roles. Admin user cannot modify details of other admin users and owner.</p> </li> <li> <p>Deactivate normal Users: Admin users can deactivate normal users. </p> </li> </ol>"},{"location":"cloud/console/#normal-user","title":"Normal User","text":"<p>Normal organisation users have the lower level of authority and can not perform any administrative actions. They can only change thier own details.</p>"},{"location":"cloud/console/#changing-the-ownership-of-the-organization","title":"Changing the ownership of the organization","text":"<p>A current owner can assign another user of the organisation as a owner. This can either be done by the Administrative user of Embever on the request from the owner of the organisation or by the owner user of the organisation him/herself. The following steps needs to be carried out to change the owner user of the organisation.</p> <ol> <li>Login to the Embever console as a owner user.</li> <li>On the Manage accounts section of the homepage click on \"Manage your organisation accounts\". You will be  redirected to the page with list of users on your organisation.</li> <li>If there are not any users besides you click on \"Create New Account\" and create a user to whom you want to transfer the ownership to.</li> <li>On, the users list, click on the \"Edit\" button for the specific user. Now you will see the Update Account form with the user details.</li> <li>Go to Role input and select \"Owner\". Make sure the user you are transferring the ownership is activated before you change the role to Owner.</li> <li>The user that you changed the owner role will receive an email with the ownership transfer request. The email contains a secure link to accept or decline the request. This link is valid for 7 days only. If the link is expired you have to reinitiate the process.</li> <li>When the user accepts the ownership transfer request. The designated user role will be changed to the owner and your role will be changed to a normal user.</li> </ol>"},{"location":"cloud/console/#update-your-own-account-details","title":"Update your own Account Details","text":"<p>As a user you can update your account details like To change your account details follow the following steps</p> <ol> <li>Login to the console.</li> <li>Click on the account icon on the top right part of the menu. A form with your details will open.</li> <li>Edit your details and click submit. If the details are upadated successfully you will see a success message on the top of the form.</li> </ol>"},{"location":"cloud/console/#otp-login","title":"OTP Login","text":"<p>OTP stands for one time password. When OTP is enabled for your account, embever console sends an email to your account email with a token. This token should be entered when you login else you are not able to log in to the console. This is one of the ways to make check if the person trying to log in is legit one. </p> <p>Recommendation</p> <p>OTP is used for the tow factor authorization and turning this on always is highly recommended to secure your account from different attacks.</p>"},{"location":"cloud/console/#activate-otp","title":"Activate OTP","text":"<p>To enable  OTP for your account follow the following steps.</p> <ol> <li>Login to the console.</li> <li>Click on the account icon on the top right part of the menu. A form with your details will open.</li> <li>On the OTP input set the checkbox to checked to enable OTP for your account and click submit.</li> <li>You will receive an email with verification link to verify the OTP along with the verification code.</li> <li>Click on the verification link and enter the verification code to verify.</li> <li>Upon successful verification you will again receive an email notification that OTP login has been activated and verified.</li> </ol>"},{"location":"cloud/console/#deactivate-otp","title":"Deactivate OTP","text":"<p>To enable disable OTP for your account follow the following steps.</p> <ol> <li>Login to the console.</li> <li>Click on the account icon on the top right part of the menu. A form with your details will open.</li> <li>On the OTP input uncheck the checkbox to disable OTP for your account and click submit.</li> <li>Upon successful update , you will receive an email that your OTP login has been deactivated.</li> </ol>"},{"location":"cloud/console/#deactivate-an-account","title":"Deactivate an Account","text":"<p>To deactivae an accont follow the following steps</p> <ol> <li>Login to the console as owner or admin user.</li> <li>On the 'Manage Accounts' seciton of the homepage click on 'Manage your organisation's Accounts'. This will open a page with list of your organization accounts.</li> <li>Click on the 'Edit' button for the account you want to deactivate. This will open a 'Update Account' form for the selected user account.</li> <li>Uncheck the 'Activated' checkbox on the form an click 'Submit'.</li> <li>Updon successful deactivation you will get the success message and the status of the user account changes from active to inactive.</li> </ol> <p>Note</p> <p>There is no option to delete user accounts from the console. Contact Embever at support@embever.com for account deletion requests.</p>"},{"location":"cloud/console/#salesforce-integration","title":"Salesforce Integration","text":""},{"location":"cloud/console/#connecting-your-salesforce-organisation-to-embever-cloud","title":"Connecting Your Salesforce Organisation to Embever Cloud","text":"<p>Your salesforce Organisation can be easily integrated to the Embever IoT core. This enables you to use the data from Embever IoT core on different business cases on your salesforce organisation.</p> <p>To connect your salesforce instance to Embever IoT Core follow the following steps:</p> <ol> <li>Go to  https://console.embever.com/integration/salesforce/new/</li> <li>Select the your type of organisation and an alias. Click on Authorize</li> <li>Next Authorize CAAM Embever by logging in with your salesforce credentials and clicking Allow. After that you will be redirected to the IoT Core console.</li> <li>Install the Embever IoT Core Salesforce App.</li> <li>After installing the IoT Core Salesforce App, Go back to your connection page on the IoT Core console</li> <li>On Install Salesforce App section, click on \"I have already installed the App\"</li> <li>Next, select the applications for the integration.</li> </ol> <p>Now you can send or receive data from the devices on the attached applications from salesforce.</p> <p>Optionally,</p> <ol> <li>You can install the sample Embever IoT Core Salesforce App by clicking the \"Install Example App in Salesforce\" button on the last section.</li> <li>Synchronize all the devices to Salesforce by simply clicking the \"Synchronize All Devices to Salesforce\" button.</li> </ol> <p>After sucessfully connecting the devices to your salesforce organisation you can now use the Platform Events defined in the IoT Core App to communicate to the device via Embever IoT Core.</p> <p>Note</p> <p>For more details on Embever cloud integration with Salesforce see here.</p>"},{"location":"cloud/console/#embever-iot-core-salesforce-app","title":"Embever IoT Core Salesforce App","text":"<p>Embever IoT Core Salesforce App contains the necessary salesforce components that are used to connect the salesforce organisation to Embever IoT Core. This app should be installed in the salesforce organistion to be able to communicate with the Embever IoT Core from salesforce. You can install this app while creating a salesforce connection in the Embever IoT Core console.</p> <p>The package contents can be categorized into mainly two groups. </p> <ol> <li>Platform Events</li> <li>Utility Functions</li> </ol>"},{"location":"cloud/console/#platform-events","title":"Platform Events","text":"<p>Embever IoT Core Salesforce App Package contains three different Platform Events definition, which is used to communicate between your salesforece organisatio  and Embever IoT Core.</p> <p>The platform events are defined are as follows:</p> <ol> <li>Device Messge</li> <li>Outbound Message</li> <li>Inbound Message</li> </ol>"},{"location":"cloud/console/#device-messsage","title":"Device Messsage","text":"<p>Platform Event for Devices is primarily used to syncronize devices from IoT Core to Salesforce. In Salesforce users can listen to this platform event and update or create their own custom Device objects using the information from the platform event.</p> Label API Name Description Data Type Required DeviceId embevercore__DeviceId__c ID of the device in Embever IoT Core Text Yes Device Name embevercore__DeviceName__c Alias Name of the device in Embever IoT Core Text Yes Device Type embevercore__DeviceType__c Indicates the type of the device connectivity technology. Contains 'virtual' for virtual devices. Otherwise contains the type of connectivity technology the device is using to communicate to Embever Core. Text Yes Application Id embevercore__ApplicationId__c The Application Id of the application the device has been assigned to in Embever Core. Text Yes Activated embevercore__Activated__c Indicates the activation status of the device. If false, the device has not been activated and cannot send or receive messages. Devices can be activated and deactivated in Embever Core. Checkbox Yes Date/Time embevercore__DateTime__c The Date/Time a message was issued. Date/Time Yes <p>Example:</p> <pre><code>{\n  \"embevercore__DateTime__c\": \"2022-02-23T11:46:39.357Z\",\n  \"CreatedById\": \"0057Q000002LlABCQA0\",\n  \"embevercore__DeviceName__c\": \"HellowWorldDev\",\n  \"CreatedDate\": \"2022-02-23T11:46:40.212Z\",\n  \"embevercore__ApplicationId__c\": \"1c43d388-ab3b-4677-9f51-05dfg597a02d\",\n  \"embevercore__Activated__c\": true,\n  \"embevercore__DeviceId__c\": \"xyzA\",\n  \"embevercore__DeviceType__c\": \"other\"\n}\n</code></pre>"},{"location":"cloud/console/#inbound-message","title":"Inbound Message","text":"<p>Inbound Message event is used to publish the transaction messages from Embever IoT core to the salesforce organisation.  Cases when inbound message platform events are used:</p> <ol> <li>When device sends an event</li> <li>When device sends a result for an action in Embever IoT core</li> <li>When an action status is updated</li> </ol> <p>By simply subscribing to this Plaform event from salesforce you can get the transaction messages from Embever IoT Core. Here we refer both the IoT Core Event and Action as a Transaction. </p> Label API Name Description Data Type Required Type embevercore__Type__c Indicates the type of the message. Allowed values are 'action' and 'event'. Text Yes Context Id embevercore__ContextId__c Contains the embevercore__Outbound__e.embevercore__ContextId__c for a specific action to link between the outbound and inbound action message if desired. In most cases, this should be the Salesforce Record Id of the Device Action Record that triggered the creation of the Outbound Message Text No Created By Core embevercore__CreatedByCore__c Indicates whether the message originated in Embever Core or within Salesforce. When true, the messages originated outside of this Salesforce Organization. Checkbox No (Defaults to Unchecked) Date/Time embevercore__DateTime__c The Date/Time a message was issued. Checkbox Yes Device Id embevercore__DeviceId__c Contains the Embever Core Device Id of the device the message is related to. Text Yes Id embevercore__Id__c Unique id of the message within Embever Core. Can be either action id or event id from Embever IoT Core. Number Yes Name embevercore__Name__c Contains the event or action name the device used when sending the payload, e.g. \"currentLocation\". Text Yes Payload embevercore__Payload__c Contains the message payload in JSON format. Can be a JSON object, JSON array, or JSON value. Long Text Area No Status Id embevercore__StatusId__c Id of the Status of the Action/Event in Action/Event Lifecycle (e.g. 'action_sent') as in the Embever IoT Core. Number No Status Name embevercore__StatusName__c Status of the Action/Event in Action/Event Lifecycle (e.g. 'action_sent'). Text No Status Changed At embevercore__StatusChangedAt__c Date Time when the status of the transaction changed. DateTime No <p>Example: Inbound Platfrom event body when sending IoT core event to Salesforce.</p> <pre><code>{\n  \"embevercore__DateTime__c\": \"2022-02-23T08:45:13.889Z\",\n  \"embevercore__StatusChangedAt__c\": null,\n  \"embevercore__Name__c\": \"wakeUp\",\n  \"embevercore__StatusName__c\": null,\n  \"embevercore__ContextId__c\": null,\n  \"embevercore__DeviceId__c\": \"xyzA\",\n  \"embevercore__StatusId__c\": null,\n  \"CreatedById\": \"0057Q000002LlABCQA0\",\n  \"embevercore__CreatedByCore__c\": false,\n  \"CreatedDate\": \"2022-02-23T08:45:15.364Z\",\n  \"embevercore__Type__c\": \"event\",\n  \"embevercore__Id__c\": 15032,\n  \"embevercore__Payload__c\": \"{\\\"lat\\\": 525841746, \\\"lon\\\": 112812903}\"\n}\n</code></pre>"},{"location":"cloud/console/#outbound-message","title":"Outbound Message","text":"<p>Outbound Message platform event is used to send message from salesforce organisation to Embever IoT Core.</p> <p>Cases when outbound message platform events are used:</p> <ol> <li>When an action is to be sent to the device</li> <li>Cancel an action</li> </ol> Label API Name Description Data Type Required Type embevercore__Type__c Indicates the type of the message. Only 'action' is allowed as a value for outbound messages. Text Yes (defaults to \"action\") Operation embevercore__Operation__c Indicates if the message should create a new action or cancel a pending action. If set to 'cancel', the action id to be canceled needs to be provided in embevercore__Id__c. Text No Context Id embevercore__ContextId__c Can be set to a value that will be sent back in the embevercore__Inbound__e.embevercore__ContextId__c field for related action responses. In most cases this should be the Salesforce Record Id of the Device Action Record that triggered the creation of the Outbound Message. Text No Created By Core embevercore__CreatedByCore__c Indicates whether the message originated in Embever Core or within Salesforce. When true, the messages originated outside of this Salesforce Organization. Checkbox Yes (Defaults to Unchecked) Device Id embevercore__DeviceId__c Contains the Embever Core Device Id of the device the message is related to. Text Yes Id embevercore__Id__c Unique id of the message within Embever Core. Can be either action id or event id from Embever IoT Core. Number No Name embevercore__Name__c Needs to be set to the Action Name that tells the Device how to handle the Payload, e.g. \"setSettings\". Text Yes Payload embevercore__Payload__c Contains the message payload in JSON format. Can be a JSON object, JSON array, or JSON value. Long Text Area No Service Level embevercore__ServiceLevel__c Can be set to the desired service level for the action. Defaults to 0. Valid service levels are: 0 - fire and forget, 1 - ensure the device received the message, 2 - ensure the device processed the message (with guaranteed response) Number No <p>Example : Outbound Platfrom event body when sending IoT core Action from Salesforce.</p> <pre><code>{\n    \"embevercore__Operation__c\": \"create\",\n    \"embevercore__DeviceId__c\": \"xyzA\",\n    \"embevercore__Name__c\": \"setLED\",\n    \"embevercore__Payload__c\": \"{ \\\"LED\\\": \\\"off\\\" }\",\n    \"embevercore__ServiceLevel__c\": 2,\n    \"embevercore__ContextId__c\": \"a027Q00000198BpQAI\"\n}\n</code></pre>"},{"location":"cloud/console/#utility-functions","title":"Utility Functions","text":"<p>Apart from the platform events IoT core salesforce app also contains some utility functions which can be used to transform data. The utilty functions defined on the IoT Core salesforce app as an Apex Class are shown below.</p> Name Description GetJsonBoolean Returns the value for a specific key with Boolean type from a JSON string GetJsonDateTime Returns the value for a specific key with DateTime type from a JSON string GetJsonDecimal Returns the value for a specific key with Decimal type from a JSON string GetJsonKeyExists Returns true if a specific key exists in a JSON string else returns false GetJsonString Returns the value for a specific key with string type from a JSON string GetJsonValue Returns a valid JSON object as a JSON string"},{"location":"cloud/salesforce/","title":"Salesforce","text":""},{"location":"cloud/salesforce/#overview","title":"Overview","text":"<p>Embever Cloud integrates seamlessly with salesforce to send the data to and from Salesforce. This enables the customers to use the data from their deices further in salesforce to make the business decisions. To connect your devices from Embever cloud to salesforce you just need to connect your salesforce organisation to Embever Cloud from the console, install the Embever IoT Core Salesforce App and synchronize the devices. After the devices are successfully connected to the salesforce organization, Embever cloud will send and receive the data to and from salesforce via the specified platform Events which are availabe in the Embever IoT Core Salesforce App Package.</p>"},{"location":"cloud/salesforce/#embever-iot-core-salesforce-app","title":"Embever IoT Core Salesforce App","text":"<p>Embever IoT Core Salesforce App contains the necessary salesforce components that are used to connect the salesforce organisation to Embever IoT Core. This app should be installed in the salesforce organistion to be able to communicate with the Embever IoT Core from salesforce. You can install this app while creating a salesforce connection in the Embever IoT Core console.</p> <p>The package contents can be categorized into mainly two groups. </p> <ol> <li>Platform Events</li> <li>Utility Functions</li> </ol>"},{"location":"cloud/salesforce/#platform-events","title":"Platform Events","text":"<p>Embever IoT Core Salesforce App Package contains three different Platform Events definition, which is used to communicate between your salesforece organisatio  and Embever IoT Core.</p> <p>The platform events are defined are as follows:</p> <ol> <li>Device Messge</li> <li>Outbound Message</li> <li>Inbound Message</li> </ol>"},{"location":"cloud/salesforce/#device-messsage","title":"Device Messsage","text":"<p>Platform Event for Devices is primarily used to syncronize devices from IoT Core to Salesforce. In Salesforce users can listen to this platform event and update or create their own custom Device objects using the information from the platform event.</p> Label API Name Description Data Type Required DeviceId embevercore__DeviceId__c ID of the device in Embever IoT Core Text Yes Device Name embevercore__DeviceName__c Alias Name of the device in Embever IoT Core Text Yes Device Type embevercore__DeviceType__c Indicates the type of the device connectivity technology. Contains 'virtual' for virtual devices. Otherwise contains the type of connectivity technology the device is using to communicate to Embever Core. Text Yes Application Id embevercore__ApplicationId__c The Application Id of the application the device has been assigned to in Embever Core. Text Yes Activated embevercore__Activated__c Indicates the activation status of the device. If false, the device has not been activated and cannot send or receive messages. Devices can be activated and deactivated in Embever Core. Checkbox Yes Date/Time embevercore__DateTime__c The Date/Time a message was issued. Date/Time Yes <p>Example:</p> <pre><code>{\n  \"embevercore__DateTime__c\": \"2022-02-23T11:46:39.357Z\",\n  \"CreatedById\": \"0057Q000002LlABCQA0\",\n  \"embevercore__DeviceName__c\": \"HellowWorldDev\",\n  \"CreatedDate\": \"2022-02-23T11:46:40.212Z\",\n  \"embevercore__ApplicationId__c\": \"1c43d388-ab3b-4677-9f51-05dfg597a02d\",\n  \"embevercore__Activated__c\": true,\n  \"embevercore__DeviceId__c\": \"xyzA\",\n  \"embevercore__DeviceType__c\": \"other\"\n}\n</code></pre>"},{"location":"cloud/salesforce/#inbound-message","title":"Inbound Message","text":"<p>Inbound Message event is used to publish the transaction messages from Embever IoT core to the salesforce organisation.  Cases when inbound message platform events are used:</p> <ol> <li>When device sends an event</li> <li>When device sends a result for an action in Embever IoT core</li> <li>When an action status is updated</li> </ol> <p>By simply subscribing to this Plaform event from salesforce you can get the transaction messages from Embever IoT Core. Here we refer both the IoT Core Event and Action as a Transaction. </p> Label API Name Description Data Type Required Type embevercore__Type__c Indicates the type of the message. Allowed values are 'action' and 'event'. Text Yes Context Id embevercore__ContextId__c Contains the embevercore__Outbound__e.embevercore__ContextId__c for a specific action to link between the outbound and inbound action message if desired. In most cases, this should be the Salesforce Record Id of the Device Action Record that triggered the creation of the Outbound Message Text No Created By Core embevercore__CreatedByCore__c Indicates whether the message originated in Embever Core or within Salesforce. When true, the messages originated outside of this Salesforce Organization. Checkbox No (Defaults to Unchecked) Date/Time embevercore__DateTime__c The Date/Time a message was issued. Checkbox Yes Device Id embevercore__DeviceId__c Contains the Embever Core Device Id of the device the message is related to. Text Yes Id embevercore__Id__c Unique id of the message within Embever Core. Can be either action id or event id from Embever IoT Core. Number Yes Name embevercore__Name__c Contains the event or action name the device used when sending the payload, e.g. \"currentLocation\". Text Yes Payload embevercore__Payload__c Contains the message payload in JSON format. Can be a JSON object, JSON array, or JSON value. Long Text Area No Status Id embevercore__StatusId__c Id of the Status of the Action/Event in Action/Event Lifecycle (e.g. 'action_sent') as in the Embever IoT Core. Number No Status Name embevercore__StatusName__c Status of the Action/Event in Action/Event Lifecycle (e.g. 'action_sent'). Text No Status Changed At embevercore__StatusChangedAt__c Date Time when the status of the transaction changed. DateTime No <p>Example: Inbound Platfrom event body when sending IoT core event to Salesforce.</p> <pre><code>{\n  \"embevercore__DateTime__c\": \"2022-02-23T08:45:13.889Z\",\n  \"embevercore__StatusChangedAt__c\": null,\n  \"embevercore__Name__c\": \"wakeUp\",\n  \"embevercore__StatusName__c\": null,\n  \"embevercore__ContextId__c\": null,\n  \"embevercore__DeviceId__c\": \"xyzA\",\n  \"embevercore__StatusId__c\": null,\n  \"CreatedById\": \"0057Q000002LlABCQA0\",\n  \"embevercore__CreatedByCore__c\": false,\n  \"CreatedDate\": \"2022-02-23T08:45:15.364Z\",\n  \"embevercore__Type__c\": \"event\",\n  \"embevercore__Id__c\": 15032,\n  \"embevercore__Payload__c\": \"{\\\"lat\\\": 525841746, \\\"lon\\\": 112812903}\"\n}\n</code></pre>"},{"location":"cloud/salesforce/#outbound-message","title":"Outbound Message","text":"<p>Outbound Message platform event is used to send message from salesforce organisation to Embever IoT Core.</p> <p>Cases when outbound message platform events are used:</p> <ol> <li>When an action is to be sent to the device</li> <li>Cancel an action</li> </ol> Label API Name Description Data Type Required Type embevercore__Type__c Indicates the type of the message. Only 'action' is allowed as a value for outbound messages. Text Yes (defaults to \"action\") Operation embevercore__Operation__c Indicates if the message should create a new action or cancel a pending action. If set to 'cancel', the action id to be canceled needs to be provided in embevercore__Id__c. Text No Context Id embevercore__ContextId__c Can be set to a value that will be sent back in the embevercore__Inbound__e.embevercore__ContextId__c field for related action responses. In most cases this should be the Salesforce Record Id of the Device Action Record that triggered the creation of the Outbound Message. Text No Created By Core embevercore__CreatedByCore__c Indicates whether the message originated in Embever Core or within Salesforce. When true, the messages originated outside of this Salesforce Organization. Checkbox Yes (Defaults to Unchecked) Device Id embevercore__DeviceId__c Contains the Embever Core Device Id of the device the message is related to. Text Yes Id embevercore__Id__c Unique id of the message within Embever Core. Can be either action id or event id from Embever IoT Core. Number No Name embevercore__Name__c Needs to be set to the Action Name that tells the Device how to handle the Payload, e.g. \"setSettings\". Text Yes Payload embevercore__Payload__c Contains the message payload in JSON format. Can be a JSON object, JSON array, or JSON value. Long Text Area No Service Level embevercore__ServiceLevel__c Can be set to the desired service level for the action. Defaults to 0. Valid service levels are: 0 - fire and forget, 1 - ensure the device received the message, 2 - ensure the device processed the message (with guaranteed response) Number No <p>Example : Outbound Platfrom event body when sending IoT core Action from Salesforce.</p> <pre><code>{\n    \"embevercore__Operation__c\": \"create\",\n    \"embevercore__DeviceId__c\": \"xyzA\",\n    \"embevercore__Name__c\": \"setLED\",\n    \"embevercore__Payload__c\": \"{ \\\"LED\\\": \\\"off\\\" }\",\n    \"embevercore__ServiceLevel__c\": 2,\n    \"embevercore__ContextId__c\": \"a027Q00000198BpQAI\"\n}\n</code></pre>"},{"location":"cloud/salesforce/#utility-functions","title":"Utility Functions","text":"<p>Apart from the platform events IoT core salesforce app also contains some utility functions which can be used to transform data. The utilty functions defined on the IoT Core salesforce app as an Apex Class are shown below.</p> Name Description GetJsonBoolean Returns the value for a specific key with Boolean type from a JSON string GetJsonDateTime Returns the value for a specific key with DateTime type from a JSON string GetJsonDecimal Returns the value for a specific key with Decimal type from a JSON string GetJsonKeyExists Returns true if a specific key exists in a JSON string else returns false GetJsonString Returns the value for a specific key with string type from a JSON string GetJsonValue Returns a valid JSON object as a JSON string"},{"location":"cloud/salesforce/#examples","title":"Examples","text":""},{"location":"cloud/salesforce/#synchronizing-devices-to-salesforce","title":"Synchronizing devices to Salesforce","text":"<p>When you are synchronizing all the devices to Salesforce from the Embever IoT Core console, a the Device Message Platfrom Event is published to  your salesforce organisation for each device in your salesforce connection.</p> <p>Example:  Payload of the message on the Device Message Platfrom event on Synchronize Devices</p> <pre><code>{\n  \"embevercore__DateTime__c\": \"2022-02-23T11:46:39.357Z\",\n  \"CreatedById\": \"0057Q000002LlABCQA0\",\n  \"embevercore__DeviceName__c\": \"HellowWorldDev\",\n  \"CreatedDate\": \"2022-02-23T11:46:40.212Z\",\n  \"embevercore__ApplicationId__c\": \"1c43d388-ab3b-4677-9f51-05dfg597a02d\",\n  \"embevercore__Activated__c\": true,\n  \"embevercore__DeviceId__c\": \"xyzA\",\n  \"embevercore__DeviceType__c\": \"other\"\n}\n</code></pre>"},{"location":"cloud/salesforce/#receiving-events-on-salesforce","title":"Receiving Events on Salesforce","text":"<p>All the events from the devices connected to your salesforce organisation will be published to the Inbound message Platform event with type event. You can read from the Inbound message Platform event from your salesforce instance and can use it further. E.g.  Event in Embever IoT Core</p> <pre><code>{\n    \"url\": \"https://api.embever.com/v2/events/15032/\",\n    \"id\": 15032,\n    \"device\": \"xyzA\",\n    \"sim\": \"89777777777777766\",\n    \"type\": \"wakeUp\",\n    \"payload\": {\n        \"lat\": 525841746,\n        \"lon\": 112812903\n    },\n    \"created_at\": \"2022-02-23T08:45:13.889841Z\"\n}\n</code></pre> <p>Correspondig message received on Subscribing to the Inbound Message Platform event (embevercore__Inbound__e)</p> <pre><code>{\n  \"embevercore__DateTime__c\": \"2022-02-23T08:45:13.889Z\",\n  \"embevercore__StatusChangedAt__c\": null,\n  \"embevercore__Name__c\": \"wakeUp\",\n  \"embevercore__StatusName__c\": null,\n  \"embevercore__ContextId__c\": null,\n  \"embevercore__DeviceId__c\": \"xyzA\",\n  \"embevercore__StatusId__c\": null,\n  \"CreatedById\": \"0057Q000002LlABCQA0\",\n  \"embevercore__CreatedByCore__c\": false,\n  \"CreatedDate\": \"2022-02-23T08:45:15.364Z\",\n  \"embevercore__Type__c\": \"event\",\n  \"embevercore__Id__c\": 15032,\n  \"embevercore__Payload__c\": \"{\\\"lat\\\": 525841746, \\\"lon\\\": 112812903}\"\n}\n</code></pre>"},{"location":"cloud/salesforce/#creating-an-action-from-salesforce","title":"Creating an Action from Salesforce","text":"<p>An Action in Embever IoT Core is the way to send message to the Device to perform certain actions. To create action on Embever IoT core you can simply publish to the Outbound Message Platform event from your Salesforce organisation.</p> <p>Example Message published on Outbound Message Platform Event to create 'setLED' action for device 'xyzA'.</p> <pre><code>{\n    \"embevercore__Operation__c\": \"create\",\n    \"embevercore__DeviceId__c\": \"xyzA\",\n    \"embevercore__Name__c\": \"setLED\",\n    \"embevercore__Payload__c\": \"{ \\\"LED\\\": \\\"off\\\" }\",\n    \"embevercore__ServiceLevel__c\": 2,\n    \"embevercore__ContextId__c\": \"a027Q00000198BpQAI\"\n}\n</code></pre> <p>Corresponding action created in the Embever IoT Core is as follows</p> <pre><code>{\n    \"url\": \"https://api.embever.com/v2/actions/5530/\",\n    \"id\": 5530,\n    \"device\": {\n        \"id\": \"xyzA\",\n        \"name\": \"HellowWorldDev\"\n    },\n    \"type\": \"setLED\",\n    \"payload\": {\n        \"LED\": \"off\"\n    },\n    \"status\": {},\n    \"webhooks\": null,\n    \"service_level\": 2,\n    \"cancelled\": false,\n    \"finished\": false,\n    \"result\": null,\n    \"created_at\": \"2022-02-23T09:32:23.779159Z\",\n    \"result_code\": null,\n    \"expiry_date\": null,\n    \"expired\": false\n}\n</code></pre> <p>On creating an action Embever IoT core also publishes a message to the Inbound Message Platform with the information on action created and the corresponding action id. Example: The payload of the Inbound message for action created is given below. The attributes 'embevercore__StatusName__c' contains the status 'action_created' and 'embevercore__Id__c' is the id of the action in Embever IoT Core. </p> <pre><code>{\n  \"embevercore__DateTime__c\": \"2022-02-23T10:35:07.068Z\",\n  \"embevercore__StatusChangedAt__c\": null,\n  \"embevercore__Name__c\": \"setLED\",\n  \"embevercore__StatusName__c\": \"action_created\",\n  \"embevercore__ContextId__c\": \"a027Q00000198BpQAI\",\n  \"embevercore__DeviceId__c\": \"xyzA\",\n  \"embevercore__StatusId__c\": null,\n  \"CreatedById\": \"0057Q000002LlABCQA0\",\n  \"embevercore__CreatedByCore__c\": true,\n  \"CreatedDate\": \"2022-02-23T10:35:07.896Z\",\n  \"embevercore__Type__c\": \"action\",\n  \"embevercore__Id__c\": 5530,\n  \"embevercore__Payload__c\": null\n}\n</code></pre>"},{"location":"cloud/salesforce/#cancelling-an-action-from-salesforce","title":"Cancelling an Action from Salesforce","text":"<p>There are cases you nolonger want the action to be sent to the devices, in that case you can easily cancel the actions from salesforce. To cancel an action you can use the same Outbound Message Platform event with the operation 'cancel'.</p> <p>Example Cancel the action with action id 5530, publish the following message to Outbound Message Platform event</p> <pre><code>{\n    \"embevercore__Operation__c\": \"cancel\",\n    \"embevercore__Id__c\": 5530,\n    \"embevercore__DeviceId__c\": \"xyzA\"\n}\n</code></pre> <p>Corresponding action in the Embever IoT Core is as follows, note the cancelled attribute is changed to true.</p> <pre><code>{\n    \"url\": \"https://api.embever.com/v2/actions/5530/\",\n    \"id\": 5530,\n    \"device\": {\n        \"id\": \"xyzA\",\n        \"name\": \"HellowWorldDev\"\n    },\n    \"type\": \"setLED\",\n    \"payload\": {\n        \"LED\": \"off\"\n    },\n    \"status\": {},\n    \"webhooks\": null,\n    \"service_level\": 2,\n    \"cancelled\": true,\n    \"finished\": false,\n    \"result\": null,\n    \"created_at\": \"2022-02-23T09:32:23.779159Z\",\n    \"result_code\": null,\n    \"expiry_date\": null,\n    \"expired\": false\n}\n</code></pre> <p>On cancelling an action Embever IoT core also publishes a message to the Inbound Message Platform with the information on action cancelled and the corresponding action id. Example: The payload of the Inbound message for action cancelled is given below. The attributes 'embevercore__StatusName__c' contains the status 'action_cancelled and 'embevercore__Id__c' is the id of the cancelled action in Embever IoT Core. </p> <pre><code>{\n    \"embevercore__DateTime__c\": \"2022-02-23T10:41:36.891Z\",\n    \"embevercore__StatusChangedAt__c\": null,\n    \"embevercore__Name__c\": \"setLED\",\n    \"embevercore__StatusName__c\": \"action_cancelled\",\n    \"embevercore__ContextId__c\": \"a027Q00000198BpQAI\",\n    \"embevercore__DeviceId__c\": \"xyzA\",\n    \"embevercore__StatusId__c\": null,\n    \"CreatedById\": \"0057Q000002LlABCQA0\",\n    \"embevercore__CreatedByCore__c\": true,\n    \"CreatedDate\": \"2022-02-23T10:41:37.603Z\",\n    \"embevercore__Type__c\": \"action\",\n    \"embevercore__Id__c\": 5530,\n    \"embevercore__Payload__c\": null\n}\n</code></pre>"},{"location":"cloud/salesforce/#receiving-response-of-an-action-to-salesforce","title":"Receiving response of an Action to Salesforce","text":"<p>A device can send the response for an action. This response is stored as an object on the result attribute of the action. For all the devices connected to the salesforce instance, on receiving the response from the device Embever IoT core publishes the message to the Inbound Message Platfrom event of  the connected salesforce organisations.</p> <p>Example: Action on Embever IoT Core with a result</p> <pre><code>{\n    \"url\": \"https://api.embever.com/v2/actions/5531/\",\n    \"id\": 5531,\n    \"device\": {\n        \"id\": \"xyzA\",\n        \"name\": \"HellowWorldDev\"\n    },\n    \"type\": \"setLED\",\n    \"payload\": {\n        \"LED\": \"off\"\n    },\n    \"status\": {\n        \"action_sent\": \"2022-02-23T11:07:50.814981+00:00\",\n        \"action_delivered\": \"2022-02-23T11:07:50.866270+00:00\",\n        \"response_received\": \"2022-02-23T11:07:50.962695+00:00\"\n    },\n    \"webhooks\": null,\n    \"service_level\": 2,\n    \"cancelled\": false,\n    \"finished\": true,\n    \"result\": {\n        \"led\": \"off\"\n    },\n    \"created_at\": \"2022-02-23T10:35:07.068386Z\",\n    \"result_code\": \"Success\",\n    \"expiry_date\": null,\n    \"expired\": false\n}\n</code></pre> <p>Corresponding message on the Salesforce Inbound Message Platform Event is given below. On recevieng the response the attribute 'embevercore__StatusName__c' contains  'response_received', 'embevercore__StatusId__c' contains the status id from the Embever IoT Core and 'embevercore__Payload__c' contains the result of the action.</p> <pre><code>{\n    \"embevercore__DateTime__c\": \"2022-02-23T11:07:50.962Z\",\n    \"embevercore__StatusChangedAt__c\": \"2022-02-23T11:07:50.952Z\",\n    \"embevercore__Name__c\": \"setLED\",\n    \"embevercore__StatusName__c\": \"response_received\",\n    \"embevercore__ContextId__c\": \"a027Q00000198BpQAI\",\n    \"embevercore__DeviceId__c\": \"xyzA\",\n    \"embevercore__StatusId__c\": 2522,\n    \"CreatedById\": \"0057Q000002LlABCQA0\",\n    \"embevercore__CreatedByCore__c\": true,\n    \"CreatedDate\": \"2022-02-23T11:07:57.017Z\",\n    \"embevercore__Type__c\": \"action\",\n    \"embevercore__Id__c\": 5531,\n    \"embevercore__Payload__c\": \"{\\\"led\\\": \\\"off\\\"}\"\n}\n</code></pre>"},{"location":"firmware/","title":"Index","text":""},{"location":"firmware/#caam-os","title":"CaaM OS","text":"<p>The CaaM OS is a turnkey embedded operating system for the Internet of Things. The purpose of CaaM OS is to enable users to build reliable and secure Embedded IoT Applications with minimum effort.</p> <p>It consists of two main components: </p> <ul> <li>Embever IoT Core for Embedded</li> <li>Embedded Application Framework</li> </ul> <p> </p>"},{"location":"firmware/#embever-iot-core-for-embedded","title":"Embever IoT Core for Embedded","text":"<p>The Embever IoT Core is software component which is part of the CaaM OS. It is responsible for two main task. Firstly to manage a stable network link, and secondly to establish secure communication with the Embever Cloud. To allow user to connect to the Embever Cloud, it is implementing a rich set of APIs. This part of the CaaM OS is closed source, distributed as a standalone library and it is require Zephyr RTOS to operate.</p>"},{"location":"firmware/#caam-application-framework","title":"CaaM Application Framework","text":"<p>The application framework is part of the CaaM OS which allows to combine the capabilities of the Embever IoT Core with a custom application logic by providing and integration layer for the User Application Framework (UAF). This functionality allows to build and deploy custom applications with the CaaM OS.</p>"},{"location":"firmware/#developer-tools","title":"Developer Tools","text":"<p>The CaaM OS is built using the Nordic nRF Connect SDK which is based on the Zephyr RTOS. It is available at https://developer.nordicsemi.com/nRF_Connect_SDK. Start building applications with the CaaM OS does not require any additional development tools since it has no other external dependencies.</p>"},{"location":"firmware/#quick-links","title":"Quick Links","text":"<p>Getting Start with the CaaM User application framework</p> <p>Embever Serial Client Application</p> <p>User Application Framework Sample Applications</p>"},{"location":"firmware/ebv_conn_lib/","title":"Embever IoT Core for Embedded","text":"<p>The Embever IoT Core for Embedded software component equip the CaaM OS with versatile IoT capabilities. It is handling the network link by controlling the network interfaces and the underlying hardware devices like the cellular modem to provide a solid and reliable channel for the communication. Also it is responsible for establishing secure communication with the Embever Cloud and providing a flexible way for IoT messaging for the rest of the system.</p>"},{"location":"firmware/ebv_conn_lib/#working-with-the-embever-iot-core-for-embedded-software-library","title":"Working with the Embever IoT Core for Embedded Software Library","text":"<p>The software library is referred as ebv_conn_lib in the development environment of the CaaM OS which deployed as a static library. To successfully link the library during the build process, the dependencies of the CaaM OS are required which is the nRF Connect SDK maintained by Nordic Semiconductor. Since the software development kit is based on the Zephyr RTOS, this process is mostly seamless and not require additional development tools. Due to that, the ebv_conn_lib can be used in any embedded environment which meet the requirements however the recommended way to use it is the project template called ebv_uaf_template which is hosted here.</p>"},{"location":"firmware/ebv_conn_lib/#quick-links","title":"Quick Links","text":"<p>Embever IoT Core for Embedded library on GitHub</p>"},{"location":"firmware/caam-app-framework/","title":"CaaM Application Framework","text":"<p>The CaaM Application Framework is a collection of software components that allows to combine the capabilities of the Embever IoT Core with a custom application logic. This means, that the CaaM OS with all its components can be used to build and deploy custom applications. The application framework provides an independent execution context  for the custom application which is call user application or user_app in the development environment. The user_app  also has access to all the underlying components of the Zephyr RTOS as well, so the development environment is almost the same as a regular embedded application.</p>"},{"location":"firmware/caam-app-framework/app-development/","title":"Application Development","text":"<p>The best way to start application development  with the CaaM Application Framework is by using the provided project template, the <code>ebv_uaf_template</code>. To set up the working environment, see the relevant guide in the tutorial section. The project template contains the embedded IoT core library the <code>ebv_conn_lib</code> as a static library with header files and the CaaM Application Framework source code. This project template is already configured to compile with the Zephyr RTOS and nRF Connect SDK.</p>"},{"location":"firmware/caam-app-framework/app-development/#structure-of-the-template-project","title":"Structure of the template project","text":"<p>The project template contains the following important folders and files:</p> <ul> <li><code>ebv_conn_lib</code> CaaM OS libraries</li> <li><code>./ebv_conn_lib/ebv_lib</code> Embedded IoT Core static library</li> <li><code>./ebv_conn_lib/ebv_lib/public_headers</code> ebv_conn_lib API header files</li> <li><code>./ebv_conn_lib/ebv_src</code> CaaM Application Framework source code</li> <li><code>examples</code> CaaM Application Framework examples</li> <li><code>scripts</code> Utility scripts</li> <li><code>usr_src</code> User application source directory</li> <li><code>CMakeLists.txt</code> Top level CMake file</li> <li><code>KConfig</code> Top level Kconfig file</li> <li><code>prj_common.conf</code> Common configurations for the CMake project</li> </ul>"},{"location":"firmware/caam-app-framework/app-development/#user-application-source-directory","title":"User application source directory","text":"<p>The most important folder is <code>usr_src</code> from a development perspective since this is the default working directory for the user application source files.</p> <p>Note</p> <p>It is worth to mention that this location of the user application source files can be updated at any time by editing the <code>user_app_directory_name</code> cmake variable in the top level CMakeLists.txt file.</p> <p>The user application source directory contains the following files:</p> <ul> <li><code>usr_main.c</code> User application main source file. This is a placeholder for the user source code</li> <li><code>user_main.h</code> User application header file. This is a placeholder for the user source code</li> <li><code>Kconfig</code> Kconfig configuration file for the user application. This is referenced from the top level KConfig file</li> <li><code>CMakeLists.txt</code> CMake file for the user application. This is referenced from the top level CMake file</li> <li><code>prj.conf</code> Configuration file for the user application</li> <li><code>app.overlay</code> DeviceTree overlay for the user application</li> <li><code>boards</code> Directory for holding the custom board definitions, this is an optional directory and not part of the template</li> </ul>"},{"location":"firmware/caam-app-framework/api/","title":"CaaM Application Framework API Documentation","text":""},{"location":"firmware/caam-app-framework/custom-app-framework/","title":"User Application Framework","text":"<p>The User Application Framework is the essential part of the Embever Connectivity Firmware which let the user to integrate a custom application logic  with the connectivity core. This feature allows a rapid development of any IoT application within the Embever Connectivity Firmware.</p> <ol> <li>Setting up the UAF development environment</li> <li>Building a custom application</li> <li>Sample applications</li> <li>UAF API documentation</li> </ol>"},{"location":"firmware/caam-app-framework/esp/","title":"Embever Serial Protocol","text":"<p>Embever Serial Protocol (ESP) is a lightweight protocol to maintain communication between the CaaM OS and an external device. It can be used to connect any devices with the Embever Cloud. The communication of the embedded devices are based on the Inter-Integrated Circuit (I2C) bus with 2 additional signals for flow controlling. The protocol is implementing a simple request-response model. To read more about the Embever Serial Protocol, please refer to the Embever Serial Protocol Specification.</p>"},{"location":"firmware/caam-app-framework/esp/#implementations-of-the-embever-serial-protocol","title":"Implementations of the Embever Serial Protocol","text":"<p>There are two basic roles in the Embever Serial Protocol, the controller and peripheral. The controller is the device in the main role of the protocol, it sends requests to the peripheral and receives responses from the peripheral. This two different roles are referred as ESPC and ESPP. The implementation of the peripheral (ESPP) is part of the CaaM OS. It is executing the commands received from the controller (ESPC) and sends responses to the controller. To read more about the ESPP, please refer to the Embever Serial Protocol Peripheral. The implementation of the controller (ESPC) is part of the Embever IoT Library, a software package provided by Embever which also aims to bring a simple and fast Embever Serial Protocol controller functionalities to any embedded device. To read more about the Embever IoT Library, please refer to the Embever IoT Library.</p>"},{"location":"firmware/caam-app-framework/esp/#recommended-use-cases-of-the-embever-serial-protocol","title":"Recommended use cases of the Embever Serial Protocol","text":"<p>Using the Embever Serial Protocol offers an easy and quick way to integrate IoT capabilities into an existing embedded device. Thanks to the Embever IoT Library, the integration of the Embever Serial Protocol Controller can be even faster so it is a good fit for evaluation and prototyping. It is also a good match for large scale, complex embedded systems where the integration on the hardware level is complex or even not fusible. The ESP is using I2C which likely already part of the system, so there is only 2 additional signals needed to pass the integration of the additional hardware unit.</p>"},{"location":"firmware/caam-app-framework/esp/esp_peripheral/","title":"Embever Serial Protocol Peripheral Application","text":"<p>The Embever Serial Protocol Peripheral (ESPP) application is implementing the peripheral role of the Embever Serial Protocol. It is designed for IoT enabled applications with simplicity in mind. It provides an interface to communicate with the embedded IoT core of the CaaM OS. With that, any external device communicating via the Embever Serial Protocol can connect and communicate with the Embever Cloud. For extended functionalities, the ESP also implement so called local control commands which are meant to set the device behaviors which is running the peripheral role of the ESP.</p>"},{"location":"firmware/caam-app-framework/esp/esp_peripheral/#implementations-of-the-espp-application","title":"Implementations of the ESPP application","text":"<p>The Embever Serial Protocol Peripheral application is using the CaaM Application Framework to integrate with the CaaM OS. It is using the same environment and APIs as any other custom application can take advantage of when using the CaaM Application Framework. Compiling the CaaM OS with the ESPP application is possible by anyone, however Embever distributes and maintains firmware images for the ESPP application.</p>"},{"location":"firmware/caam-app-framework/esp/esp_specification/","title":"Embever Serial Protocol Specification","text":"<p>The Embever Serial Protocol (ESP) is an embedded protocol built by Embever to provide an easy way for embedded devices to communicate with each other in order to send and receive IoT oriented messages. The communication is based on the request-response model, where the device in the main role sending a request to the client device and the client device responding with a response, the possible request are called commands. There is two type of response kinds available in the Embever Serial Protocol, the direct or immediate response and the delayed response.</p>"},{"location":"firmware/caam-app-framework/esp/esp_specification/#request-response-model-of-the-embever-serial-protocol","title":"Request-response model of the Embever Serial Protocol","text":""},{"location":"firmware/caam-app-framework/esp/esp_specification/#commands-of-the-embever-serial-protocol","title":"Commands of the Embever Serial Protocol","text":""},{"location":"firmware/caam-app-framework/esp/embever-iot-library/","title":"Embever IoT library","text":""},{"location":"firmware/caam-app-framework/esp/embever-iot-library/#source-code","title":"Source code","text":"<p>{{ EIOT }} releases are available from here. {{ EIOT }} development code is available from here.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/#overview","title":"Overview","text":"<p>{{ EIOT }} aims at providing an easy to use library to working with the Embever IoT solutions. The {{ EIOT }} managing the {{ master }} role to handle any Embever IoT device which is supported by the . The supported Embever IoT modules are the followings:</p> <ul> <li>CaaM development boards</li> </ul>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/#features","title":"Features","text":"<p>feature highlight:</p> <ul> <li>Fully feature {{ ESP }} driver</li> <li>Simple to use payload delivery system</li> <li>Generic way to build IoT messages</li> <li>Arduino framework support</li> <li>Integration layer</li> </ul>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/getting-started/","title":"Getting Started","text":"<p>This document serves as a guide through the basic steps that are necessary to start building IoT applications with the Embever Cloud as a Module Development Kit and gives a brief overview of our stack. The goal is to provide just enough information to be able to get familiar with the IoT world without being too overwhelming. To be able to complete this guide, an Arduino compatible hardware will be necessary.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/getting-started/#embever-iot-software-library","title":"Embever IoT software library","text":"<p>To make it even simpler, Embever provides an additional software library that handles the ESP on its own. There is no need to fully understand our protocol and implement a custom software library to be able to use the Embever CaaM development board. With this simplicity, starting to work on an IoT application was never that easy, without the heavy proprietary communication protocol handling. The Embever IoT software library is platform-independent and does not contain any peripheral drivers. In this way, it can be easily integrated into any existing environment. To create sample applications, we chose the Arduino framework to make communication possible between an external device and the Embever CaaM development kit. In our mind, the Arduino Framework is a great tool to show how things work and the idea is easily adaptable to other platforms as well.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/getting-started/#summary","title":"Summary","text":"<p>To summarize the above topics before starting to work with the examples:</p> <ul> <li>Configure the hardware by shorting the right solder jumpers     based on the required behavior</li> <li>Connect the CaaM board with an external device</li> <li>Supply power to the system, the easiest way is to use a lithium     polymer battery with a JST connector</li> </ul>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/getting-started/#introducing-the-embever-cloud-system","title":"Introducing the Embever Cloud System","text":"<p>Embever IoT Core is responsible to handle all messaging to and from a device. The Embever IoT Core provides an API to easily send and receive data from a device. Besides this, it can also be used to manage resources like devices and firmwares.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/getting-started/#activating-the-embever-account","title":"Activating the Embever Account","text":"<p>When an order is submitted for the Embever Cloud As A Module development kit, an account is automatically created with the given details and an email is sent to activate the newly created account. To set up the account simply follow the link in the received email. With the personal credentials, logging in to the Embever Cloud console or to the Embever Cloud Browsable API is now possible.</p> <p>To manage the resources use the Embever Cloud Browsable API. Go to the https://api.embever.com/v2/devices/ where all the personal devices should be listed.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/getting-started/#connecting-the-device-to-the-embever-cloud-system","title":"Connecting the device to the Embever Cloud System","text":""},{"location":"firmware/caam-app-framework/esp/embever-iot-library/getting-started/#setting-up-the-arduino-environment","title":"Setting up the Arduino environment","text":"<p>The Arduino IDE is a well known integrated development environment to support all kinds of Arduino compatible devices. The Arduino IDE needs to be installed in order to compile the Embever IoT library. Moreover there are 2 necessary modifications that need to be done on the Arduino Wire library before it would be usable to work with the Embever IoT library. The Embever IoT library needs to send longer messages that the default Arduino Wire library can handle. The easiest way to locate them is to get information about the Arduino Core library location. The Arduino IDE carries this information under the Preference sub menu.</p> <p></p> <p>The following path shows the location of the arduino core. Using this example, in this case the files can found in the following location: <code>/Users/macbook/Library/Arduino15/packages/arduino/hardware/avr/1.8.3/libraries/Wire/src/Wire.h</code> <code>/Users/macbook/Library/Arduino15/packages/arduino/hardware/avr/1.8.3/libraries/Wire/src/utility/twi.h</code></p> <p>| Note: This location will vary on other systems!</p> <p>Change the following lines according to the following:</p> <p>Wiring library modifications</p> File Location Change from Change to <code>Wire.h</code> line 29 <code>#define BUFFER_LENGTH 32</code> <code>#define BUFFER_LENGTH 128</code> <code>Twi.h</code> line 34 <code>#define TWI_BUFFER_LENGTH 32</code> <code>#define TWI_BUFFER_LENGTH 128</code> <p>With this modification, the Embever IoT library will be able to send the right messages over I2C.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/getting-started/#setting-up-the-embever-iot-library-in-arduino-ide","title":"Setting up the Embever IoT library in Arduino IDE","text":"<p>To be able to use the Embever IoT library, it need to be installed to the Arduino IDE first. The Embever IoT library is depends on the CWPack library.</p> <p>Download the libraries from the following links by the download source code button and select the .zip option:</p> <ul> <li>Embever IoT     Library</li> <li>CWPack Library</li> </ul> <p>Add the downloaded files to the Arduino IDE:</p> <ul> <li>1 Open Arduino ID</li> <li>2 Select: <code>Sketch / Include Library / Add .ZIP Library\u2026</code></li> <li>3 Add both downloaded files in this way</li> </ul> <p>To open an example from the Embever IoT library from the Arduino IDE select <code>File / Examples / Embever IoT Library / Hello_Cloud</code>. Compile the Sketch and Upload to the device and open the Serial Terminal from the Arduino IDE to see the logs.</p> <p>To see the result in the Embever Cloud System go to the Browsable API.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/getting-started/#modifying-the-hello_cloud-example","title":"Modifying the Hello_Cloud example","text":"<p>Extending the Hello_Cloud example is a great way to get familiar with the Embever IoT library and with the Embever Cloud System. Let's extend the existing payload by adding another key value pair to it. Add the following line just under line 31: <code>ebv_iot_addGenericPayload(\\\"description\\\", \\\"first_demo\\\");</code></p> <p></p> <p>Verify the result in the cloud system after the sketch was uploaded to the device. Working with the Embever IoT solution is fun because it has a lot of potential to build and deploy the IoT applications of the future. To see more examples, dig deeper in the library and read about the whole API, check the Embever IoT library documentation here.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/installation/","title":"Installation","text":""},{"location":"firmware/caam-app-framework/esp/embever-iot-library/installation/#dependencies","title":"Dependencies","text":"<p>The depends on the CWPack library written by Claes Wihlborg (available here). To use the all dependencies should be fulfilled.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/installation/#install-as-an-arduino-library","title":"Install as an Arduino library","text":"<p>The easiest way to install the is to add it as an external library since the structure of the repository is design to be compatible with an Arduino library.</p> <p>The is distributed on GitLab where can be downloaded as a compressed file (to get more information about handling a compressed libraries in Arduino IDE please refer the following article). Installing by arduino-cli is also possible using the <code>arduino-cli lib install</code> command. The arduino-cli can install a library directly from a remote repository, in this way, downloading an archive file is not necessary. For more information follow this link.</p> <p>Note</p> <p>Using <code>arduino-cli</code> to install the may require to enable unsafe sources. Use the following command to enable installing from zip file:   <code>arduino-cli config set library.enable_unsafe_install true</code></p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/installation/#verifying-the-installation","title":"Verifying the installation","text":"<p>To make sure that the libraries are correctly installed, try to compile one of the sample application which can be found between the Arduino sample applications.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/integration_guide/","title":"Integration Guide","text":"<p>To be able to use the {{ EIOT }} the {{ INT_LAYER }} needs to be set up. The {{ INT_LAYER }} provides access to the hardware resources in order to establish communication with an Embever IoT device. For more information about the {{ INT_LAYER }} refer to the Integration layer topic under the API section.</p> <p>Integrating the {{ EIOT }} will take 3 parts: the Embever {{ I2C }} driver, the Embever GPIO driver and the {{ DELAY_FUNC }}. The integration layer needs to be set up before using the other parts of the {{ EIOT }} .</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/integration_guide/#integrating-the-delay_func","title":"Integrating the {{ DELAY_FUNC }}","text":"<p>The is {{ DELAY_FUNC }} necessary to the Embever IoT Library to ddetect timeout events. The following example shows how to set up the {{ DELAY_FUNC }} using the Arduino framework.</p> <pre><code>ebv_delay_register(delay);\n</code></pre> <p>Note</p> <p>The functions passed to the delay registration routine expects only 1 argument, which defines the delay value in milliseconds.</p> <p>The function definition is the following:</p> <pre><code>void ebv_delay_register(void (*delay)(unsigned long ms));\n</code></pre>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/integration_guide/#integrating-the-gpio_drv","title":"Integrating the {{ GPIO_DRV }}","text":"<p>The {{ GPIO_DRV }} requires 2 functions to be able to read the digital signals on the designed pins. To set it up, you need to provide those 2 functions and then register them on <code>ebv_esp_gpio_cb</code> (more details bellow). Take a look at the following code sample, using the Arduino framework:</p> <pre><code>#define PIN_EBV_IRQ     ARDUINO_PIN_A2\n#define PIN_EBV_READY   ARDUINO_PIN_A3\n\n// Interface function for reading the ready state\nbool gpio_readReady(){\n    return digitalRead(PIN_EBV_READY);\n}\n\n// Interface function for reading the irq state\nbool gpio_readIrq(){\n    return digitalRead(PIN_EBV_IRQ);\n}\n</code></pre> <p>The above example shows the 2 required interface functions which can fullfil the {{ GPIO_DRV }} requirements. The functions should have <code>boolean</code> return type based on the following logic.</p> <p>Return value logic</p> GPIO Pin logic level Function return HIGH <code>true</code> LOW <code>false</code> <p>After defining those functions they should be registered into the {{ GPIO_DRV }} using the <code>ebv_esp_gpio_cb</code> structure. A possible implementation might look\\'s like the following:</p> <pre><code>struct ebv_esp_gpio_cb gpio_cb;\ngpio_cb.readReady = gpio_readReady;\ngpio_cb.readIRQ = gpio_readIrq;\nebv_esp_gpio_registerGpio(&amp;gpio_cb);\n</code></pre>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/integration_guide/#integrating-the-embever-i2c-driver","title":"Integrating the Embever {{ I2C }} Driver","text":"<p>To integrate the Embever {{ I2C }} Driver, a few interface functions need to be set up. Starting with a possible implementation first and then discussing them in details.</p> <pre><code>void wire_begin(uint8_t address){\n    Wire.beginTransmission(address);\n}\n\nvoid wire_end(){\n    Wire.endTransmission();\n}\n\nint wire_available(){\n    return Wire.available();\n}\n\nsize_t wire_write(uint8_t data){\n    return Wire.write(data);\n}\n\nvoid wire_requestFrom(uint8_t address, uint8_t nof_bytes){\n    Wire.requestFrom(address, nof_bytes);\n}\n\nint wire_read(){\n    return Wire.read();\n}\n</code></pre>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/integration_guide/#void-wire_begin-uint8_t-address","title":"void wire_begin (uint8_t address)","text":"<p>Initiate the device address by the <code>address</code> parameter and prepare the peripheral to transmit data (but don\\'t transmit anything to the bus yet).</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/integration_guide/#size_t-wire_write-uint8_t-data","title":"size_t wire_write (uint8_t data)","text":"<p>Copy <code>data</code> to the internal buffer. Not sending anything to the bus yet. Return 1 if the operation was successful, return 0 if not.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/integration_guide/#void-wire_end","title":"void wire_end ()","text":"<p>Flushes the internal buffers, if any, by writing them to the {{ I2C }} bus and issue a stop sequence.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/integration_guide/#void-wire_requestfromuint8_t-address-uint8_t-nof_bytes","title":"void wire_requestFrom(uint8_t address, uint8_t nof_bytes)","text":"<p>Issues a read sequence on the {{ I2C }} bus and tries to read <code>nof_bytes</code> from device specified by <code>address</code>. Puts the incoming data into an internal buffer.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/integration_guide/#int-wire_available","title":"int wire_available ()","text":"<p>Returns the number of received bytes during the last transaction.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/integration_guide/#int-wire_read","title":"int wire_read()","text":"<p>Reads the incoming data from the internal buffer. This function reads and returns only 1 byte from the internal buffer. This function should called only if there are data in the internal buffer only. If the internal buffer is empty, should return with -1.</p> <p>As the above topic suggest, implementing the required {{ I2C }} driver can be more challenging than the {{ GPIO_DRV }} implementation. Using an internal receive and transmit buffer might also be necessary to fullfil the requirements. The Embever {{ I2C }} Driver interface was inspired by the Arduino Wire library. To get more information about the working principles and the expectation of the Embever {{ I2C }} Driver, take look at the Arduino Wire library.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/api/","title":"API documentation","text":"<p>Current stable version:</p> <p>The API documentation aims to describe the working principles of the library. Showing how to use it and how to interact with it by providing description about each modules with examples and hinting recommendations.</p> The Embever IoT library stack"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/api/ebv_esp_gnss/","title":"Embever GNSS","text":"<p>The Embever GNSS API is part of the {{ EIOT }}. This API provides access to the CaaM development board GNSS submodule. The list of the obtainable data is the following:</p> <ul> <li>Latitude, Longitude, Accuracy, Altitude</li> <li>Speed, Heading</li> <li>Date, Time</li> </ul>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/api/ebv_esp_gnss/#esp-gnss-api","title":"ESP GNSS API","text":"<p>Queries GNSS information from the CaaM development board is possible by calling a query function:</p> <pre><code>ebv_gnss_data_t gnss_data;\nbool ret = ebv_local_query_gnss(&amp;gnss_data);\n</code></pre> <p>The code snippet above will populate the <code>gnss_data</code> structure. This type has the following elements:</p> <pre><code>typedef struct{\n    double lat;\n    double lon;\n    float altitude;\n    float accuracy;\n    float speed;\n    float heading;\n    bool has_fix;\n    esp_gnss_datetime_t datetime;\n} ebv_gnss_data_t;\n</code></pre> <p>Checking the state of the GPS receiver module is possible by reading the <code>has_fix</code> flag. In case of a <code>true</code> value, the GPS data is available.</p> <p>Another way of getting GNSS data is to build a custom query.</p> <pre><code>ebv_gnss_data_t gnss_data;\nebv_local_query_gnss_custom_init();\nebv_local_query_gnss_custom_add(EBV_GNSS_REQUEST_SPEED);\nebv_local_query_gnss_custom_add(EBV_GNSS_REQUEST_DATETIME);\nebv_local_query_gnss_custom_add_submit(&amp;gnss_data);\n</code></pre> <p>The code sample above builds a custom GNSS query. This can be useful if not all the available GNSS data is necessary to read. While building a custom query the following enumerations are valid to pass as an argument:</p> <pre><code>typedef enum {\n    EBV_GNSS_REQUEST_LOCATION = 0,\n    EBV_GNSS_REQUEST_SPEED,\n    EBV_GNSS_REQUEST_DATETIME,\n} ebv_gnss_request_kind;\n</code></pre>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/api/ebv_esp_gnss/#api-documentation","title":"API documentation","text":"<p>Header file: <code>ebv_local.h</code> Source file: <code>ebv_local.cpp</code></p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/api/ebv_iot_msg/","title":"Embever IoT Messaging","text":"<p>The Embever IoT Messaging layer is the top layer of the and is the only one that the user application shall interact with. The Embever IoT Messaging layer contains all the necessary functions which can be required during transferring data between the cloud and devices. The high level functions are designed to be easy to understand and simple to use.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/api/ebv_iot_msg/#data-exchange-with-the-embever-cloud-system","title":"Data exchange with the Embever Cloud system","text":"<p>To be able to use the Embever IoT solutions successfully, a few working principles need to be clarified. Exchanging data with the Embever Cloud System is done in 3 major forms:</p> <ul> <li>Events</li> <li>Actions</li> <li>Responses</li> </ul>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/api/ebv_iot_msg/#the-embever-cloud-event","title":"The Embever Cloud Event","text":"<p>An event is the way to send data from the device to the cloud and has two fiels:</p> <ul> <li>type (string): event kind</li> <li>payload (key-pair string): event content</li> </ul> <p>This fields can be used freely during designing an application. The payload is organized by key-value pairs like the following:</p> <pre><code>{\n    \"key\":\"value\",\n    \"led_state\":\"on\"\n}\n</code></pre>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/api/ebv_iot_msg/#the-embever-cloud-action","title":"The Embever Cloud Action","text":"<p>An action is the way to send data from the cloud to the device and has four fields:</p> <ul> <li>type (string): action kind</li> <li>id (integer): action unique identification</li> <li>payload (key-pair string): action content</li> <li>service_level (integer): sets the action lifetime and supports     3 different service levels:<ul> <li>0: The action lives in the cloud while it has been sent to     the device</li> <li>1: The action lives in the cloud while a response is not     submitted for it</li> <li>2: The action lives in the cloud while a successful response     is not submitted to it</li> </ul> </li> </ul> <p>For example, an action with service level 0 will be in the cloud while it is not queried by the device. As soon as the device queries it, it will be marked in the cloud and not be sent to the device anymore. On the other hand, actions with service level 1 or 2 will be send all the time, when the device queries actions until a response is not submitted for them. The difference between service level 1 and service level 2 is manner of the response result. In case of service level 1 the action will be marked and not be sent to the device again if it get any valid response, the result code in this response can be indicate failure or success, the action will be marked in both cases. In case of service level 2 the action will be marked only if the response contain a success result code.</p> <p>The id is automatically assigned on the cloud side and can be omitted, the other fields can be used freely during designing an application. The payload is organized by key-value pairs.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/api/ebv_iot_msg/#the-embever-cloud-response","title":"The Embever Cloud Response","text":"<p>A response is a way to set the result of an action. It is a special type of event, where the corresponding action identifier should be carried by the device and sent to the cloud. It has tree fields:</p> <ul> <li>id (integer): should match the corresponding action</li> <li>result_code (integer): should be 0 for success and 1     for failure (as default on unix systems)</li> <li>payload (key-pair string): response optional content</li> </ul> <p>As seen, the organization of the user payload is made by key-value pairs just like a JSON object. This form makes possible to easily separate and identify each value during their transfer to the cloud.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/api/ebv_iot_msg/#message-type-rules","title":"Message type rules","text":"<p>The <code>type</code> field of an Embever IoT message is used to identify the corresponding message. There are some rules in this naming schema which need to be fulfil. The rules are the followings:</p> <ul> <li>Can not start with <code>_</code> (e.g. <code>_sensor1</code> is invalid)</li> <li>Can not be one of the following, this are reserved for the Embever     Cloud System<ul> <li><code>getFile</code></li> </ul> </li> </ul>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/api/ebv_iot_msg/#sending-data-to-the-cloud-with-the","title":"Sending data to the cloud with the","text":"<pre><code>ebv_iot_initGenericEvent(\"event_type_1\");\nebv_iot_addGenericPayload(\"key1\", \"value1\");\nebv_iot_addGenericPayload(\"key2\", \"value2\");\nebv_iot_submitGenericEvent();\n</code></pre> <p>Sending data to the cloud is as simple as the above lines of code. First create an event and set its type. The type can be any string which fullfils the mentioned rules.</p> <p>Next, specify a 2 key-value pair as part of the payload. Call this function several times if you want to add more fields to the payload. Finally, call the last function to submit the event to the cloud.</p> <p>Let\\'s see a practical example: sending temperature data of an apartment to the cloud. A possible implementation would be the following:</p> <pre><code>ebv_iot_initGenericEvent(\"Temperature\");\nebv_iot_addGenericPayload(\"living_room\", 24.7);\nebv_iot_addGenericPayload(\"bath_room\", 28.2);\nebv_iot_addGenericPayload(\"kitchen\", 26.1);\nebv_iot_addGenericPayload(\"bed_room\", 23);\nebv_iot_addGenericPayload(\"is_alarm_triggered\", false);\nebv_iot_submitGenericEvent();\n</code></pre> <p>The sample above covers temperature data from 4 different places around the apartment and indicating an alarm state too. The equivalent data in JSON is the following:</p> <pre><code>[\n    \"Temperature\",\n    {\n        \"living_room\" : 24.7,\n        \"bath_room\" : 28.2,\n        \"kitchen\" : 26.1,\n        \"bed_room\" : 23,\n        \"is_alarm_triggered\" : false\n    }\n]\n</code></pre>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/api/ebv_iot_msg/#api-documentation","title":"API documentation","text":"<p>Header file: <code>ebv_iot.h</code> Source file: <code>ebv_iot.cpp</code></p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/api/esp_drv/","title":"Embever Serial Protocol driver","text":""},{"location":"firmware/caam-app-framework/esp/embever-iot-library/api/esp_drv/#about-the-embever-serial-protocol","title":"About the Embever Serial Protocol","text":"<p>The Embever Serial Protocol (or ESP) is a simple to use serial protocol design to establish communication with an Embever IoT device. The ESP is based on the protocol and using 2 addition signals.</p> <p>There are 2 main rules in the ESP:</p> <ul> <li>refereed as an application microcontroller (AM)</li> <li>which is the Embever IoT device</li> </ul> <p>To read more about the the refer the following documentation: ESP protocol definition</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/api/integration_layer/","title":"The Integration Layer","text":"<p>The {{ INT_LAYER }} aims to connect the {{ EIOT }} with an external set of functions or with a library which can provide the necessary functions to drive the {{ I2C }} bus and handle the GPIO interface. In this way, the {{ EIOT }} is capable of use any underlying implementation to issue commands on the {{ I2C }} bus and read digital states of a GPIO pin.</p> <p>To achieve this functionality, the designed functions shall be provided to the trough an internal type. This methodology is widely used to set up interfaces in C language. There are already supported platforms in the {{ INT_LAYER }} , which can be used off-the-shelf.</p> <p>The supported frameworks are:</p> <ul> <li>Arduino</li> </ul> <p>Using the supported platforms is straightforward. There are macro definitions for setting up the necessary functions and passing them to the {{ INT_LAYER }} .</p> <p>The example below shows how to set it up for the Arduino Wire Library.</p> <pre><code>#include &lt;Arduino.h&gt;\n#include &lt;Wire.h&gt;\n#include \"ebv_iot.h\"\n\n// Define interface functions\nEBV_SETUP_ARDUINO_CB;\n\nvoid setup() {\n    // Passing the interface to the Integration layer\n    EBV_REGISTER_ARDUINO_CB;\n}\n\nvoid loop(){\n\n}\n</code></pre> <p>To get more information about how to set up and use the {{ INT_LAYER }} please refer the Integration Guide-guide topic.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/api/logging/","title":"Logging Module","text":"<p>The makes it possible to write logs by calling a simple function. The usage is the same as the standard <code>printf</code> function:</p> <pre><code>p(\"Starting application: version %d\", app_version);\n</code></pre>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/api/logging/#setting-up-the","title":"Setting up the","text":"<p>The process of setting up the is similar to the process which is used by the . For example, using the Arduino Serial Library, the setup would be the following:</p> <pre><code>// Integration function\nvoid log_print(char *str){\n    Serial.print(str);\n}\n\nvoid setup(){\n    Serial.begin(9600);\n    // Integration function registration\n    p_registerPrint(log_print);\n}\n</code></pre> <p>As the code examples shows, the registered function should be able to handle a string argument. Setting up the using the Arduino framework can be done by using the predefined support macros:</p> <pre><code>LOG_SETUP_ARDUINO;\n\nvoid setup() {\n    Serial.begin(9600);  // start serial for output\n    LOG_REGISTER_ARDUINO;\n}\n</code></pre>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/","title":"Sample Applications","text":"<p>The supplied Sample Applications can give a practical overview of the Embever IoT library. The goal is to provide ideas about possible implementations, using them as a template project and clarify the functionalities.</p> <p>Each sample application is a standalone IoT application using the Arduino framework. Because of that, porting them to another framework is straightforward. To see more, select one of the sample applications.</p> <p>Note</p> <p>All the sample applications are expecting an already prepared    development environment and a hardware</p> <ul> <li>Hello Cloud</li> <li>Dash Button</li> <li>IoT Blinky</li> <li>GNSS Simple</li> <li>GNSS Report</li> <li>Power Down</li> </ul>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/cloud_blinky/","title":"IoT Blinky","text":"<p>Application name : <code>iot_blinky</code></p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/cloud_blinky/#overview","title":"Overview","text":"<p>The IoT Blinky sample application is a simple application which is receiving and sending data from/to the cloud. This example requires additional hardware setup to work properly: a push button and an LED need to be connected to the arduino board. The following table shows the necessary connections.</p> <p>Hardware Connections</p> Hardware Pin Logic Button D2 Active LOW LED D3 Active HIGH <p>For more information about the hardware connection, refer the   Wiring Digaram with Additional Component.</p> <p>The working principles of this application are the following: It is fetching data from the cloud from time to time and then reading the response if any. To do this, it is using an action. This is the way to get data from the cloud to the device. To get more information about the Embever IoT Messaging, take a look at the Embever IoT Messaging topic.</p> <p>After the action is received, the application checks its type and parses the message payload accordingly. Based on that information the external LED will light up or be switched off. Moreover a response for each action will be submitted. In this way, the cloud system can verify the result of an action.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/cloud_blinky/#flashing","title":"Flashing","text":"<p>Uploading this application to an Arduino compatible board is easy: navigate to the examples and select the <code>iot_blinky</code> from the Embever IoT library in Arduino IDE. Upload the sketch to the board, and see the result in the serial terminal.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/cloud_blinky/#testing-the-application","title":"Testing the Application","text":"<p>To test the application, the necessary hardware connections should be done (as mentioned before). After powering up the device, the following information should appear in the serial terminal:</p> <pre><code>IoT Blinky starting...\n</code></pre> <p>Pushing the external button will start the fetching process. The following message should appear in the serial terminal:</p> <pre><code>Fetching...\n</code></pre> <p>This means that the application started to look for actions. You should now create the following action in the cloud:</p> <pre><code>{\n    \"device\": {\n        \"id\": \"&lt;&lt;ID&gt;&gt;\"\n    },\n    \"type\": \"setLED\",\n    \"payload\": {\n        \"state\": \"on\"\n    }\n}\n</code></pre> <p>Note</p> <p>Replace the &lt;&lt;ID&gt;&gt; placeholder to the the device ID</p> <p>With the <code>\"state\":\"on\"</code> payload, the state of the external LED can be set. With the action creation, the device should change the state of the external LED according to the action. To verify the response from the device, navigate to the corresponding action in the cloud system and see the result. The device should submit the following result and result payload:</p> <pre><code>\"result\": {\n        \"LED\": \"on\"\n    },\n\"result_code\": \"Success\",\n</code></pre> <p>Note</p> <p>The result payload is set by the state of the external LED.</p> <p>To continue experimenting with the sample application, submit more actions in the cloud system and see the result on the device.</p> <p>An optional upgrade for this application is to add more LED\\'s and implement a logic to support them. A possible solution is extending the action payload by adding a <code>led_id</code> key. According to this value, change the corresponding LED state. The new action can be the following:</p> <pre><code>{\n    \"device\": {\n        \"id\": \"&lt;&lt;ID&gt;&gt;\"\n    },\n    \"type\": \"setLED\",\n    \"payload\": {\n        \"led_id\": 1\n        \"state\": \"on\"\n    }\n}\n</code></pre> <p>The new response:</p> <pre><code>\"result\": {\n        \"LED\": \"on\"\n        \"id\":   1\n    },\n\"result_code\": \"Success\",\n</code></pre>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/dash_btn/","title":"Dash Button","text":"<p>Application name : <code>dash_button</code></p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/dash_btn/#overview","title":"Overview","text":"<p>The Dash Button sample application is a simple application which is sending data to the cloud. This example requires additional hardware setup to work properly: a push button and an LED need to be connected to the arduino board. The following table shows the necessary connections.</p> <p>Hardware Connections</p> Hardware Pin Logic Button D2 Active LOW LED D3 Active HIGH <p>For more information about the hardware connection, refer the   Wiring Digaram with Additional Component.</p> <p>The working principles of this application are the following: it sends data to the cloud at every button presses. To achieve this task, it is using an event. This is the way to send data from the device to the cloud. To get more information about the Embever IoT Messaging, take a look at the Embever IoT Messaging topic.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/dash_btn/#flashing","title":"Flashing","text":"<p>Uploading this application to an Arduino compatible board is easy: navigate to the examples and select the <code>dash_button</code> from the Embever IoT library in Arduino IDE. Upload the sketch to the board and see the result in the serial terminal.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/dash_btn/#testing-the-application","title":"Testing the Application","text":"<p>To test the application, the necessary hardware connections should be done (as mentioned before). After powering up the device, the following information should appear in the serial terminal:</p> <pre><code>DashButton demo starting...\n</code></pre> <p>To send the event to the cloud press the external button. The external LED will light up for 15 seconds.</p> <p>To verify the event which is just sent, go to the cloud system and check the events. Should look like the following:</p> <pre><code>{\n    \"type\": \"buttonPressed\",\n    \"payload\": {\n        \"name\": \"1\"\n    }\n}\n</code></pre> <p>To continue experimenting with the sample application, press the external button several times. A possible upgrade for this application is to add and implement more external triggers (like buttons) and change the <code>name</code> value according to the trigger source.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/gnss_report/","title":"GNSS Report","text":"<p>Application name : <code>gnss_report</code></p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/gnss_report/#overview","title":"Overview","text":"<p>The GNSS Report sample application is using the location report feature of the {{ CaaM }} board. This example requires additional hardware setup to work properly: a push button and an LED need to be connected to the arduino board. To wire up the hardware devices, follow the instruction in the Wiring Diagram with no Additional Component topic.</p> <p>The working principle of this application is to instruct the {{ CaaM }} board to send location data to the cloud. This is especially useful when the application mcu has limited resources because it does not need to handle all the gnss data and build the cloud message. The type of the location event and the content of this event is preset, the application mcu can not change it.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/gnss_report/#flashing","title":"Flashing","text":"<p>To upload this application to an Arduino compatible board navigate to the examples and select the <code>gnss_report</code> from the Embever IoT library in Arduino IDE. Upload the sketch to the board and see the result in the serial terminal.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/gnss_report/#testing-the-application","title":"Testing the Application","text":"<p>To test the application, the necessary hardware connections should be done (as mentioned before). After powering up the device, the following information should appear in the serial terminal:</p> <pre><code>GNSS Report sample starting\n</code></pre> <p>To issue the location report command press the external button. The following message will appear in the serial terminal:</p> <pre><code>Report request submitted\n</code></pre> <p>After some time (at maximum 5 minute), based on the result of the location report command the following message will be sent to the serial terminal:</p> <pre><code>Location data sent to the cloud\n</code></pre> <p>In case of unsuccessful location report:</p> <pre><code>GPS fix timeout, location data not sent\n</code></pre> <p>To receive a valid position and other data, a suitable GPS signal quality must be present.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/gnss_simple/","title":"GNSS Simple","text":"<p>| Application name : <code>gnss_simple</code></p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/gnss_simple/#overview","title":"Overview","text":"<p>The GNSS Simple sample application is a simple application which is querying GNSS data. This example does not require any additional hardware, just an Arduino compatible board and a compatible Embever CaaM device supported by the Embever IoT library. To wire up the hardware devices, follow the instruction in the Wiring Diagram with no Additional Component topic.</p> <p>The working principle of this application is to query and show a different kind of GNSS data.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/gnss_simple/#flashing","title":"Flashing","text":"<p>To upload this application to an Arduino compatible board navigate to the examples and select the <code>gnss_simple</code> from the Embever IoT library in Arduino IDE. Upload the sketch to the board and see the result in the serial terminal.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/gnss_simple/#testing-the-application","title":"Testing the Application","text":"<p>To test the application, the necessary hardware connections should be set up (as mentioned before). After powering up the device, it starts querying GNSS data. To receive a valid position and other data, a suitable GPS signal quality must be present.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/hello_cloud/","title":"Hello Cloud","text":"<p>Application name : <code>hello_cloud</code></p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/hello_cloud/#overview","title":"Overview","text":"<p>The Hello Cloud sample application is a simple application which is sending data to the cloud. This example does not require any additional hardware, just an arduino compatible board and a compatible Embever CaaM device supported by the Embever IoT library. To wire up the hardware devices, follow the instruction in the Wiring Diagram With No Additional Component topic.</p> <p>The working principles of this application is quite simple: it sends data to the cloud only one time. To achieve this task, it is using an event. This is the way to send data from the device to the cloud. To get more information about the Embever IoT Messaging, take a look at the Embever IoT Messaging.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/hello_cloud/#flashing","title":"Flashing","text":"<p>Uploading this application to an Arduino compatible board is easy: navigate to the examples and select the <code>hello_cloud</code> from the Embever IoT library in Arduino IDE. Upload the sketch to the board and see the result in the serial terminal.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/hello_cloud/#testing-the-application","title":"Testing the Application","text":"<p>To test the application, the necessary hardware connections should be set up (as mentioned before). After powering up the device, the following information should appear in the serial terminal.</p> <pre><code>Hello Cloud starting...\nSending hello_cloud event...\nEvent sent to the cloud\n</code></pre> <p>Now the event should be sent to the cloud. Verify it in the Embever Cloud System. The submitted event should be the following content:</p> <pre><code>{\n    \"type\": \"Hello_Cloud\",\n    \"payload\": {\n        \"source\": \"ebv_demo\"\n    }\n}\n</code></pre>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/pwr_down/","title":"Power Down Mode","text":"<p>Application name : <code>ebv_pwr_down</code></p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/pwr_down/#overview","title":"Overview","text":"<p>This sample application is using the power down mode feature of the {{ CaaM }} board. This example requires additional hardware setup to work properly: a push button and an LED need to be connected to the arduino board. To wire up the hardware devices, follow the instruction in the Wiring Diagram with no Additional Component topic.</p> <p>The working principle of this application is to illustrate the {{ CaaM }} board power down mode. This is especially useful for battery powered applications.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/pwr_down/#flashing","title":"Flashing","text":"<p>To upload this application to an Arduino compatible board navigate to the examples and select the <code>ebv_pwr_down</code> from the Embever IoT library in Arduino IDE. Upload the sketch to the board and see the result in the serial terminal.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/pwr_down/#testing-the-application","title":"Testing the Application","text":"<p>To test the application, the necessary hardware connections should be done (as mentioned before). After powering up the device, the following information should appear in the serial terminal:</p> <pre><code>Power down mode test sample\n</code></pre> <p>To start the demo press the external button. The following message will appear in the serial terminal:</p> <pre><code>Sending sample event\nEvent sent\nPut CaaM board to power down mode and wait 1 minute...\nSleep mode activated\n</code></pre> <p>After a sample event is sent to the cloud, the power down mode is activated. About 1 minute later the sample application going to wake up the {{ CaaM }} board to send the sample event again.</p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/wiring_led_btn/","title":"Wiring Diagram With Additional Component","text":"<p>The following diagram is showing an overview about connecting the Embever IoT module to an Arduino UNO. In this setup there is 2 additional component connected. An applicable logic level shifter can be any of the following:</p> <ul> <li>SparkFun Logic Level Converter -     Bi-Directional</li> <li>4-channel I2C-safe Bi-directional Logic Level     Converter</li> <li>TXB0104 Bi-Directional Level     Shifter</li> </ul> <p></p>"},{"location":"firmware/caam-app-framework/esp/embever-iot-library/samples/wiring_simple/","title":"Wiring Diagram With No Additional Component","text":"<p>The following diagram is showing an overview about connecting the Embever IoT module to an Arduino UNO. In this setup there is no additional hardware connected. An applicable logic level shifter can be any of the following:</p> <ul> <li>SparkFun Logic Level Converter -     Bi-Directional</li> <li>4-channel I2C-safe Bi-directional Logic Level     Converter</li> <li>TXB0104 Bi-Directional Level     Shifter</li> </ul> <p></p>"},{"location":"fragments/mcuboot_pem_keys/","title":"Mcuboot pem keys","text":"<p>To embed secure firmware update into the deployment process, the firmware binary has to be signed with a unique key. Ignoring this option and using the default keys of the SDK is not forbidden for internal development, but as soon as the firmware pass the development stage, it is recommended to use a custom keys to maintain security.</p> <p>Note</p> <p>To use the default keys to sign the firmware binaries, remove ( or make the line begin with the <code>#</code> sign to disable it) the following line in the <code>mcuboot.conf</code> file.</p> <pre><code>CONFIG_BOOT_SIGNATURE_KEY_FILE=\"fota-keys/nRF9160/dev/mcuboot-ec-p256.pem\"\n</code></pre> <p>To generate a custom signing keys, follow this guide written by the Nordic Semiconductor team. The newly generated keys can be places to any location and they can be referenced with they absolute path. Using a relative path is also possible ( like the default value of the <code>CONFIG_BOOT_SIGNATURE_KEY_FILE</code> ). In this case the base directory of this relative path is the following location:</p> <p><code>&lt;nrf_sdk_base&gt;/&lt;version_number&gt;/bootloader/mcuboot</code></p> <p>As an example, the absolute location of the signing key is : <code>/opt/nordic/ncs/v2.2.0/bootloader/mcuboot/fota-keys/nRF9160/dev/mcuboot-ec-p256.pem</code></p>"},{"location":"fragments/ncs_setup_uaf/","title":"Ncs setup uaf","text":"<p>Setting up the software development environment starts with the nRF Connect SDK installation, follow the official guide written by the Nordic Semiconductor team here. Choose the nRF Connect SDK version 2.2.0 from the Toolchain Manager.</p> <p>Note</p> <p>If this version is not listed on the Toolchain Manager, change the setting of the application based on the screenshot below.</p> <p></p> <p>Note</p> <p>If the mentioned SDK version is not listed, turn off the \u201cShow only 3 newest minor version\u201d option on the Toolchain Manager settings page.</p> <p>To exploit all the possibilities of the development experience, review this page as well. To verify the local development environment, try to compile and upload one of the nordic sample application.</p> <p></p>"},{"location":"fragments/vscode_ncs_compile_flash/","title":"Vscode ncs compile flash","text":"<p>To build the application, use the Build Configuration button or use one of the built-in build tasks of the nRF Connect extension.</p> <p></p>"},{"location":"fragments/vscode_ncs_uaf_template_import/","title":"Vscode ncs uaf template import","text":"<p>To start working with the UAF template, open the nRF Connect SDK IDE, which is the Visual Studio Code with the Nordic nRF Connect SDK plugin. To do that, click on the \"Open VS Code\" button in the nRF Connect Desktop Toolchain Manager. Importing the UAF template is as simple as clicking to the Open Application button after selecting the nRF Connect extension tab on the sidebar in VS Code.</p> <p></p> <p>Opening the UAF template as and existing application by the Open Application button As the application opened successfully, the next step is to define a build target</p> <p></p> <p></p> <p>Build configuration successfully defined, SDK and toolchain version set to 2.2.0</p>"},{"location":"getting_started/","title":"Index","text":""},{"location":"getting_started/#choosing-the-right-integration-path","title":"Choosing the Right Integration Path","text":"<p>Cloud as a Module (CaaM) empowers users to create reliable and secure IoT applications with minimal effort. CaaM offers a comprehensive set of IoT features and secure connectivity, right out of the box. There are two primary integration options available with the CaaM solution:</p>"},{"location":"getting_started/#1-established-application-firmware","title":"1. Established Application Firmware","text":"<p>This integration is ideal for existing applications that require IoT capabilities. The CaaM embedded solution provides a lightweight, easy-to-use, IoT-focused communication protocol that leverages common serial bus systems like I2C, SPI, or UART. This option is the quickest way to unlock the advantages of IoT connectivity. To get started, please refer to the Embever Serial Protocol Guide.</p>"},{"location":"getting_started/#2-new-product-development","title":"2. New Product Development","text":"<p>This integration is best suited for developing new IoT products. The CaaM Application Firmware allows you to run custom embedded firmware directly on the main control unit, offering seamless integration and maximizing the potential of the CaaM embedded operating system. To begin with the CaaM Application Framework, consult the CaaM Application Framework Guide.</p> <p>If neither of these options covers your specific needs, please contact us. We are eager to assist you in finding the best solution for your application.</p>"},{"location":"getting_started/cloud/","title":"Cloud","text":""},{"location":"getting_started/cloud/#data-model","title":"Data Model","text":""},{"location":"getting_started/cloud/#device","title":"Device","text":"<p>Device is an entity in which the CaaM hardware is installed and sends data to the cloud. A device has a single or multiple sim cards which is used for the cellular conneciton.</p>"},{"location":"getting_started/cloud/#events","title":"Events","text":"<p>Events are represents the data sent from the CaaM hardware to the Embever IoT core cloud. Event is used to trigger a transmission of a data. Each Event object is of a specific type and might have additional information (payload) that was sent by the hardware.</p>"},{"location":"getting_started/cloud/#actions","title":"Actions","text":"<p>Actions are the operations or instructions that are sent to the device. Each Action object is of a specific type and might have additional information (payload) that shall be sent to the device, e.g. some settings or other information that is needed to process the action. A corresponding response for the action can be sent by the device.  An action can have different service level. A service level tells if the action is guranteed to be received by the device or not. Actions with Srevice level 0 are sent to the device and not guranteed to be delivered or processed by the device. Action with service level 1 is guranteed to be received by the device, and with service level 2 are gruanteed to be processed by the device.</p>"},{"location":"getting_started/cloud/#files","title":"Files","text":"<p>Files can be sent to and from a CaaM hardware. </p>"},{"location":"getting_started/cloud/#ota-update","title":"OTA Update","text":"<p>Embever IoT Core cloud provides an easy way to do Over the Air update. A deployment can be created for a group of devices and asssign a firmwary binary to the devices.This can be created using the API <code>/deployments</code> endpoint. On the background the deployment creates a special type of Action with type <code>_fota</code> with service level 2 which is sent to the device. On receiving the <code>_fota</code> action the device then downloads the firmware from a file transfer server from the cloud and sends back the response on the corresponding action with the result.</p> <p>Note</p> <p>Currently it is not possible to upload your own firmware for OTA updates. You need to provide the firmware binarys to Embever to deploy the updates to your devices.</p>"},{"location":"getting_started/cloud/#console","title":"Console","text":"<p>Embever IoT Core cloud provides the user interface to manage different resources via console. The console is reachable under link https://console.embever.com. Using the conosle you can</p> <ul> <li>Update the Details of your organisation</li> <li>Add Accounts for a user</li> <li>Update the Accounts</li> <li>Enable/Disable the OTP for users</li> <li>Create/Manage the Salesforce connections</li> <li>Navigate to the Browsable API</li> </ul>"},{"location":"getting_started/cloud/#cloud-api","title":"Cloud API","text":"<p>The Cloud API provides an easy programmatic way to manage your resources as well as interact with the CaaM devices. The cloud API provides different endpoints for this purpose. It is deployed under . For details see API Reference</p>"},{"location":"getting_started/cloud/#developer-tools","title":"Developer Tools","text":"<p>Python API client node API client</p>"},{"location":"getting_started/esp/","title":"Esp","text":""},{"location":"getting_started/esp/#embever-serial-protocol","title":"Embever Serial Protocol","text":""},{"location":"getting_started/esp/#prerequisites","title":"Prerequisites","text":"<p>Ensure the following prerequisites are met before proceeding with this guide:</p> <ul> <li>An activated account for the Embever IoT Core. For more information, see Creating an Embever IoT Core Account.</li> <li>A supported hardware device with a SIM card provided by Embever. For details, refer to Supported hardware devices.</li> </ul>"},{"location":"getting_started/esp/#introduction","title":"Introduction","text":"<p>The Embever Serial Protocol (ESP) is a lightweight communication protocol designed to facilitate interaction between the CaaM embedded operating system (CaaM-OS) and external devices. It enables seamless connectivity to the Embever Cloud. Communication between devices is based on common serial buses like I2C, SPI, and UART with additional flow control mechanisms. ESP implements a simple request-response model, where external devices send requests to CaaM-OS, and CaaM-OS responds accordingly. For more details, refer to the Embever Serial Protocol Specification.</p>"},{"location":"getting_started/esp/#verify-the-firmware-of-the-caam-hardware-device","title":"Verify the Firmware of the CaaM Hardware Device","text":"<p>The appropriate CaaM-OS firmware for the Embever Serial Protocol must be active on the CaaM hardware device. This application firmware is maintained and provided by Embever for supported hardware devices. Standard CaaM hardware devices come preloaded with the ESP application firmware. However, it is possible to build the same application firmware for other hardware devices by compiling CaaM-OS with the ESP application. For more information, refer to the Embever Serial Protocol Peripheral Application.</p>"},{"location":"getting_started/esp/#the-embever-iot-library","title":"The Embever IoT Library","text":"<p>The Embever IoT library is a software library developed and maintained by Embever to provide an easy and efficient way to integrate the ESP into existing applications. The library implements the initiator role of the ESP which is reposible for sending commands to the CaaM hardware device to perform various tasks. Since the Embever IoT library is written in C and includes a dedicated integration layer, it can be ported to many different platforms. The Embever IoT library is available at the following repository: Embever IoT Library.</p>"},{"location":"getting_started/firmware/","title":"CaaM Application Framework","text":"<p>The CaaM OS allows to integrate custom application logic with the Embever IoT Core. This means, that no other programable unit is required to deploy an IoT enabled application. Using a rich set of APIs and standard embedded development tools, building IoT applications was never that easy. To get started, take a look at the User Application Framework topic.</p>"},{"location":"getting_started/firmware/#embever-serial-client-application","title":"Embever Serial Client Application","text":"<p>The Embever Serial Protocol (ESP) is a lightweight serial protocol designed for Internet of Things applications. The Embever Serial Client (ESC) application is an ESP command interpreter implementing the ESP client role. The ESC is designed to be easily integrated into any existing embedded environment, providing a simple API to communicate with the Embever Cloud. This setup allows easy integration of any CaaM board into an existing embedded system. To read more about the Embever Serial Client application, see the Embever Serial Client topic.</p>"},{"location":"getting_started/hardware/","title":"Hardware","text":"<p>Meet the CaaM Mini, an easy-to-use evaluation board running the Caam OS on an nRF9160 SoC from Nordic Semiconductor. It allows to use LTE networks like LTE Cat-NB1, LTE Cat-M1 and it is equipped with an integrated GNSS receiver. The CaaM Mini minimalistic design makes it perfect for prototyping and evaluating IoT applications. Due to its small form factor, the CaaM Mini is ideal to integrate with any kind of hardware.</p>"},{"location":"getting_started/hardware/#prototyping","title":"Prototyping","text":"<p>One of the main goals of the CaaM board family is to make the prototyping and evaluation phase as smooth as possible. The CaaM Mini is designed to be used in the prototyping phase. It allows to set up a hardware prototype with any kind of hardware event without an external micro controller unit. Thanks to the wide range of operating voltage and low current consumption capabilities, the CaaM Mini can be used to evaluate battery powered applications as well. Moreover, using the Embever Serial Protocol, a lightweight serial protocol based on I2C , takes only 4 data lines to set up an IoT enabled device.</p>"},{"location":"getting_started/hardware/#production","title":"Production","text":"<p>To put the CaaM boards to the next level, it might be required to design a custom printed circuit board in order to make a perfect fit for the IoT enabled hardware device. For this purpose the hardware blueprints of the CaaM hardware is available to anyone, along with support and guidance from Embever. Only 3 active components are required to fulfill the CaaM hardware design requirements, shrinking down the development time and being cost effective from the first design sketch to mass production. For more information see the Customization and Integration section here</p>"},{"location":"getting_started/overview/","title":"What is Cloud-as-a-Module (CaaM)","text":"<p>Cloud as a Module is a connectivity service which transfers data cellularly from your device hardware to the Cloud and can forwards it to any ERP system or external systems. It can be fully incorporated into any electronic devices and using the exposed API/libraries on the hardware side the device can send the data to the cloud. CaaM provides full connectivity as a service solution by simplifying MNO integration, energy efficient transfer which leds to faster time to market for an IoT Product. Not only it is faster to develop IoT solutions with CaaM but it is also easier to maintain and reliable.</p>"},{"location":"getting_started/overview/#quick-links","title":"Quick Links","text":"<ul> <li>Getting started with Arduino using the CaaM-Mini</li> <li>Introduction to CaaM embedded firmware</li> <li>Introduction to CaaM hardware</li> <li>API documentation </li> <li>Integration with third party web applications</li> </ul>"},{"location":"getting_started/uaf/","title":"CaaM Application Framework","text":"<p>The CaaM Application Framework (UAF) provides a comprehensive set of APIs to accelerate the development of IoT applications, with built-in connectivity to the Embever IoT Core. This framework simplifies sending telemetry data to the cloud by offering easy-to-use APIs, reducing the complexity of implementing connectivity, secure communication, and other critical IoT tasks.</p> <p>To learn more about the User Application Framework API, refer to the UAF API Documentation.</p>"},{"location":"getting_started/uaf/#sending-telemetry-data-to-the-cloud-using-uaf","title":"Sending Telemetry Data to the Cloud Using UAF","text":"<p>This quick start guide demonstrates how to send device telemetry to the cloud. The Embever IoT Core Browsable API will be used to view the telemetry data.</p>"},{"location":"getting_started/uaf/#prerequisites","title":"Prerequisites","text":"<p>Ensure the following requirements are met to complete this guide:</p> <ul> <li>An activated account for the Embever IoT Core. See Creating an Embever IoT Core Account.</li> <li>A supported hardware device with an Embever-provided SIM card. See Supported hardware devices.</li> </ul> <ul> <li>Visual Studio Code installed on the development machine (optional but recommended).</li> </ul>"},{"location":"getting_started/uaf/#sign-in-to-embever-iot-core-browsable-api","title":"Sign In to Embever IoT Core Browsable API","text":"<p>Sign in to the Embever IoT Core Browsable API. Keep the portal open while following this guide.</p>"},{"location":"getting_started/uaf/#ensure-the-sim-card-is-allocated-to-the-correct-organization","title":"Ensure the SIM Card Is Allocated to the Correct Organization","text":"<p>To list available SIM cards, go to the SIM resource endpoint. Verify that the SIM card used by the CaaM device is listed and activated. The <code>iccid</code> attribute of the SIM resource should match the ICCID of the physical SIM card in the CaaM device.</p>"},{"location":"getting_started/uaf/#create-a-device-in-the-embever-iot-core","title":"Create a Device in the Embever IoT Core","text":"<p>A device instance in the Embever IoT Core represents a single physical IoT device.</p> <p>Note</p> <p>If the CaaM Development Kit was provided by Embever, the device may already be created in the Embever IoT Core. To check available devices, go to the Devices API Endpoint. If the device is listed, skip this section.</p> <p>The simplest way to create a device is by using the Browsable API, though other tools like Postman or curl can also be used. This guide will use the Browsable API to perform the task.</p> <ol> <li>Visit the Devices API Endpoint. Ensure that the correct account credentials are used.</li> <li>Scroll to the bottom of the page to find a form for inputting device data. Both HTML and raw input formats are available for initiating a POST request to create a new device. The raw data format will be used in this example.</li> <li>Set the media type field to <code>application/json</code>.</li> <li> <p>In the content field, input the following data:</p> <pre><code>{\n    \"name\": \"&lt;your_device_name&gt;\",\n    \"activated\": true,\n    \"sims\": [\"&lt;iccid_of_sim&gt;\"]\n}\n</code></pre> <p>Replace <code>&lt;your_device_name&gt;</code> with a unique name for the device (names should be unique within the organization). Replace <code>&lt;iccid_of_sim&gt;</code> with the ICCID of the SIM card used by the CaaM device.</p> </li> <li> <p>Click the <code>POST</code> button. This will create a device in the Embever IoT Core. A similar object will be returned:</p> <pre><code>{\n    \"url\": \"https://api.embever.com/v2/devices/4w4QD/\",\n    \"id\": \"4w4QD\",\n    \"name\": \"&lt;your_device_name&gt;\",\n    \"password\": \"**********************\",\n    \"activated\": true,\n    \"application\": null,\n    \"webhooks\": null,\n    \"meta\": null,\n    \"sims\": [\"&lt;iccid_of_sim&gt;\"],\n    \"created_at\": \"2024-06-14T07:37:23.361080Z\"\n}\n</code></pre> </li> </ol> <p>Once the device is created, it is ready to receive telemetry data from the CaaM device.</p>"},{"location":"getting_started/uaf/#run-the-sample-application","title":"Run the Sample Application","text":"<p>The CaaM Application Framework simplifies and accelerates IoT product development by providing essential IoT functionalities out of the box. These include telemetry data transfer, file transfers, firmware updates, and more. The framework handles complex connectivity, protocol management, and security implementations, allowing the focus to remain on building the application. For more details, refer to the CaaM Application Framework.</p>"},{"location":"getting_started/uaf/#step-1-setting-up-the-software-development-environment","title":"Step 1: Setting Up the Software Development Environment","text":"<p>Setting up the software development environment starts with the nRF Connect SDK installation, follow the official guide written by the Nordic Semiconductor team here. Choose the nRF Connect SDK version 2.2.0 from the Toolchain Manager.</p> <p>Note</p> <p>If this version is not listed on the Toolchain Manager, change the setting of the application based on the screenshot below.</p> <p></p> <p>Note</p> <p>If the mentioned SDK version is not listed, turn off the \u201cShow only 3 newest minor version\u201d option on the Toolchain Manager settings page.</p> <p>To exploit all the possibilities of the development experience, review this page as well. To verify the local development environment, try to compile and upload one of the nordic sample application.</p> <p></p>"},{"location":"getting_started/uaf/#step-2-get-a-local-copy-of-the-embever-user-application-framework-template","title":"Step 2: Get a Local Copy of the Embever User Application Framework Template","text":"<p>To obtain a local copy of the CaaM User Application Framework template, clone the repository or download the distributed archive.</p> <p>Note This repository contains submodules necessary for its operation.</p> <p>Use the following command to ensure that the submodules are downloaded:</p> <pre><code>git clone --recurse-submodules git@github.com:Embever/ebv_UAF_template.git\n</code></pre> <p></p>"},{"location":"getting_started/uaf/#step-3-working-with-the-uaf-template","title":"Step 3: Working with the UAF Template","text":"<p>To work with the UAF template, follow these steps to set up the environment and prepare the application for development:</p> <ol> <li>Open Visual Studio Code: Once the repository is cloned, open Visual Studio Code.</li> <li>Import the UAF Template: Import the cloned UAF template into the workspace.</li> </ol> <p>To start working with the UAF template, open the nRF Connect SDK IDE, which is the Visual Studio Code with the Nordic nRF Connect SDK plugin. To do that, click on the \"Open VS Code\" button in the nRF Connect Desktop Toolchain Manager. Importing the UAF template is as simple as clicking to the Open Application button after selecting the nRF Connect extension tab on the sidebar in VS Code.</p> <p></p> <p>Opening the UAF template as and existing application by the Open Application button As the application opened successfully, the next step is to define a build target</p> <p></p> <p></p> <p>Build configuration successfully defined, SDK and toolchain version set to 2.2.0</p>"},{"location":"getting_started/uaf/#step-4-crypto-keys-for-binary-encryption","title":"Step 4: Crypto Keys for Binary Encryption","text":"<p>To secure firmware, generate cryptographic keys for binary encryption. Follow the steps below to set up the necessary keys:</p> <p>To embed secure firmware update into the deployment process, the firmware binary has to be signed with a unique key. Ignoring this option and using the default keys of the SDK is not forbidden for internal development, but as soon as the firmware pass the development stage, it is recommended to use a custom keys to maintain security.</p> <p>Note</p> <p>To use the default keys to sign the firmware binaries, remove ( or make the line begin with the <code>#</code> sign to disable it) the following line in the <code>mcuboot.conf</code> file.</p> <pre><code>CONFIG_BOOT_SIGNATURE_KEY_FILE=\"fota-keys/nRF9160/dev/mcuboot-ec-p256.pem\"\n</code></pre> <p>To generate a custom signing keys, follow this guide written by the Nordic Semiconductor team. The newly generated keys can be places to any location and they can be referenced with they absolute path. Using a relative path is also possible ( like the default value of the <code>CONFIG_BOOT_SIGNATURE_KEY_FILE</code> ). In this case the base directory of this relative path is the following location:</p> <p><code>&lt;nrf_sdk_base&gt;/&lt;version_number&gt;/bootloader/mcuboot</code></p> <p>As an example, the absolute location of the signing key is : <code>/opt/nordic/ncs/v2.2.0/bootloader/mcuboot/fota-keys/nRF9160/dev/mcuboot-ec-p256.pem</code></p>"},{"location":"getting_started/uaf/#step-5-compiling-and-flashing","title":"Step 5: Compiling and Flashing","text":"<p>Once the crypto keys are set up, proceed with compiling and flashing the firmware onto the CaaM device:</p> <ol> <li>Compiling: Use the build tools in Visual Studio Code to compile the project.</li> <li>Flashing: After the compilation is complete, the firmware binaries are ready to be flashed to the CaaM device. This can be done by selecting the \"Flash\" option in the sidebar.</li> </ol> <p>Note: Depending on the specific CaaM device being used, the flashing process may differ. For example, the CaaM Mini does not have a built-in programmer, so an external programming tool must be used. For more details, see the CaaM-OS Hardware Compatibility page.</p>"},{"location":"getting_started/uaf/#step-6-the-dash-button-sample-application","title":"Step 6: The Dash Button Sample Application","text":"<p>The UAF template includes several sample applications located in the <code>./samples</code> folder. The dash button sample application will be used to demonstrate sending telemetry data to the cloud.</p> <ol> <li> <p>Add a Build Configuration: Edit the existing build configuration or create a new one, as shown in the screenshots below:</p> <p> </p> </li> <li> <p>Select the Dash Button Application: Add the following CMake argument to select the Dash Button sample application:</p> <pre><code>-DUSER_APPLICATION=\"dash_button\"\n</code></pre> </li> <li> <p>Build and Flash: After configuring, build the project and flash the application binary. Once flashed, the status LED on the device should turn on, indicating that the application is running. For development purposes, it is recommended to view the logs generated by CaaM-OS. To learn more about accessing the log messages, refer to the CaaM-OS Logs section.</p> </li> </ol> <p>The CaaM-OS will complete the telemetry data transfer when the status LED begins blinking. For further explanation of the Dash Button sample application, refer to the Dash Button Sample Application for the CaaM Application Framework article.</p>"},{"location":"getting_started/uaf/#step-7-viewing-telemetry-data-in-the-embever-iot-core-browsable-api","title":"Step 7: Viewing Telemetry Data in the Embever IoT Core Browsable API","text":"<p>After the CaaM device sends telemetry data, the data can be viewed in the Embever IoT Core using the Browsable API. Follow these steps:</p> <ol> <li>Open the Browsable API: Visit <code>https://api.embever.com/v2/events/?device=&lt;your_device_id&gt;</code> to access the telemetry data.</li> <li>Replace <code>&lt;your_device_id&gt;</code>: Substitute <code>&lt;your_device_id&gt;</code> with the actual ID of the CaaM device.</li> </ol> <p>Telemetry data is represented as events. Each event object contains a type, which denotes a specific occurrence on the device, and a payload, which includes additional details about that occurrence. Below is an example of telemetry data sent by a device:</p> <pre><code>[\n    {\n        \"url\": \"https://api.embever.com/v2/events/123456/\",\n        \"id\": 123456,\n        \"device\": \"my-test-dev\",\n        \"sim\": \"8988XXXXXXXXXXX\",\n        \"type\": \"samples\",\n        \"payload\": {\n            \"temp\": 20\n        },\n        \"created_at\": \"2024-06-05T14:44:38.497395Z\"\n    }\n]\n</code></pre> <p>The Embever IoT Core makes it easy to forward telemetry data to other cloud applications. For more details, refer to the following guides:</p> <ul> <li>How to send data from the Embever IoT Core to other applications,</li> <li>Integration with Salesforce,</li> <li>Integration with Azure IoT Hub</li> </ul>"},{"location":"getting_started/uaf/#next-steps","title":"Next Steps","text":"<ul> <li>Sample Applications of the CaaM Application Firmware</li> <li>CaaM Application Framework API</li> <li>Best Practices for developing IoT applications with the CaaM Application Firmware</li> </ul>"},{"location":"hardware/dev-board/","title":"Index","text":""},{"location":"hardware/dev-board/#the-embever-caam-development-board","title":"The Embever CaaM development board","text":"<p>In the process of getting to know the CaaM board, let it start with a feature highlight.</p> <p></p> <ul> <li>1 Battery connector, JST2B 2mm pitch</li> <li>2 nanoSIM adapter</li> <li>3 Cellular antenna connector, U.FL</li> <li>4 GPS antenna connector, U.FL</li> <li>5 Reset button</li> <li>6 Status indicator LED, blue</li> <li>7 SIM chip, eSIM</li> <li>8 Buck/Boost voltage regulator circuitry</li> <li>9 GPS/LTE modem, LTE-M1, NB-IOT</li> </ul>"},{"location":"hardware/dev-board/#recommended-operating-conditions","title":"Recommended Operating Conditions","text":"Property Min Max Unit Operating Voltage 1.8 5.5 V VDD_GPIO 1.8 3.6 V Operating Temperature -20 85 \u00b0C Peak Power Consumption 1 A"},{"location":"hardware/dev-board/#jumper-configuration","title":"Jumper Configuration","text":"<p>Solder jumpers can be used to modify the behavior of the hardware. The location of these solder jumpers are shown in the following figure:</p> <p></p> <p>The solder jumpers have the following functionalities:</p> <p>Solder Jumpers</p> Solder jumper Functionality SJ1 Short to activate the external SIM cardIf this solder jumper is shorted, the modem starts using the nanoSIM instead of the eSIM. SJ3 Short to set the GPIO logic level to 3.3V.There is the option to select the voltage level of the GPIO pins, which can be anything between 1.8v and VCC.It can be useful when you wish to interface with a device which is running on a lower voltage level than 3.3v. SJ2 Short to connect the board VCC with the TAG connector VCC pin.It might be required by an external programmer if the firmware of the modem is to be updated manually. SJ4 Short to activate pullup resistors on i2c lines.The pullup resistors are necessary to communicate with the device.Use external pullup resistors if you do not wish to use the internal ones."},{"location":"hardware/dev-board/#wiring-up-the-hardware","title":"Wiring up the hardware","text":"<p>For using the Embever CaaM development board, it has to be connected to an external device. To establish digital communication with the CaaM development board, there are a few necessary signals that need to be connected. The following figure shows the location of these signals by board versions:</p> CaaM board revision 2 <p></p> <p>ESP Pinout</p> Signal Name Description VIN Supply Voltage input GND Ground PWR_EN Enable power, active LOW, enabled by default VDD_IO Supply Voltage for GPIO Pins 3V3 Internal voltage regulator output SDA ESP data line SCL ESP clock line IRQ ESP logic line, active low READY ESP logic line, active high CaaM board revision 2.1 <p></p> <p>ESP Pinout</p> Signal Name Description VIN Supply Voltage input GND Ground PWR_EN Enable power, active LOW VDD_IO Supply Voltage for GPIO Pins 3V3 Internal voltage regulator output SDA ESP data line SCL ESP clock line IRQ ESP logic line, active low READY ESP logic line, active high"},{"location":"hardware/dev-board/#powering-the-embever-caam-development-board","title":"Powering the Embever CaaM development board","text":"<p>There are multiple ways to supply the Embever CaaM development board. The JST connector can be used to attach an external battery. The VIN pin can also be used to supply power from the pin header. The specification that needs to be considered is the input voltage range that the CaaM development board can safely use and the current delivery capability of the external power source. To get those values, take a look at the Recommended Operating Conditions.</p> <p>On the other hand, the CaaM development board can also be used to provide power output through the 3V3 pin. It can provide 3.3 Volt to an external device (150mA max).</p>"},{"location":"hardware/dev-board/#digital-communication-logic-level","title":"Digital communication logic level","text":"<p>It is necessary to match the logic level between an external device and the Embever CaaM development board to establish stable communication. This is possible by supplying any voltage in the supported voltage range to the VDD_IO pin. To omit the wiring for this pin, the SJ3 solder jumper can be used to set the logic voltage level to VCC which is 3.3 Volt.</p>"},{"location":"hardware/dev-board/#communication-with-the-embever-caam-development-board","title":"Communication with the Embever CaaM development board","text":"<p>To address digital communication with the Embever CaaM development board a lightweight protocol is used, the Embever Serial Protocol (ESP). For more information about it, see Embever Serial Protocol Driver</p> <p>To use the Embever Serial Protocol, connect an external device based on the following table:</p> <p>ESP Wiring</p> Signal name Description SDA Serial Data SCL Serial Clock READY Device ready to receive IRQ Data available to read <p>Note</p> <p>Make sure to use an Arduino board that fulfils the voltage level requirements. The Embever CaaM board is not 5V tolerant. For example, to be able to use an Arduino UNO board, a voltage level shifter might be necessary.</p>"},{"location":"links/account_management/","title":"Account management","text":""},{"location":"links/account_management/#accounts-management","title":"Accounts Management","text":"<p>Embever IoT Core offers different user roles, each with specific permissions to manage resources effectively.</p>"},{"location":"links/account_management/#user-roles","title":"User Roles","text":"<p>The users are primarily categorized into two groups.</p> <ol> <li> <p>Administrative users</p> <p>Administrative users are responsible or managing the Embever Console and the resources. These users are further categorized into two roles.</p> <ol> <li> <p>Superuser: Has full control over all aspects of the Embever Console, including user management and resource allocation.</p> </li> <li> <p>Staff User: Assigned to users for specific administrative tasks by superusers.</p> </li> </ol> </li> <li> <p>Organization Users</p> <p>Organization users are individuals associated with a particular organization and are typically assigned specific roles and permissions within the system. The organisational users are categorized further into three roles.</p> <ol> <li> <p>Owner: Has the highest level of authority within the organization. Can perform administrative tasks and manage other users.</p> </li> <li> <p>Admin User: Granted administrative privileges within the organization, such as user management and resource allocation.</p> </li> <li> <p>Normal User: Has limited permissions, typically restricted to accessing and interacting with assigned resources.</p> </li> </ol> </li> </ol> <p>Note</p> <p>There are additional user types specifically for API which doesnot have accounts for logging into the console. They are called organisation user and applicaiton user. Organisation user and application user are created automatically when an organisation or an application is created. These are created to provide scope on the organisational level and applicaiton for api requests. </p>"},{"location":"links/account_management/#owner-user","title":"Owner User","text":"<p>Owners possess the highest level of control and can perform the following administrative actions.</p> <ol> <li> <p>Assign Another Owner: Owners can designate another user as an owner of the organization.</p> </li> <li> <p>Create Users: Owners can create new users within the organization.</p> </li> <li> <p>Edit Users: Owners can modify user details and roles.</p> </li> <li> <p>Delete Users: Owners cannot directly delete users. Contact support@embever.com for user deletion requests. However, owners can deactivate the users, the deactivated users are no longer able to login and use the console.</p> </li> </ol>"},{"location":"links/account_management/#admin-user","title":"Admin User","text":"<p>Admin users have the second highest level of authority and can perform the following administrative actions.</p> <ol> <li> <p>Create Users: Admin users can create new users within the organization.</p> </li> <li> <p>Edit Users: Admin user can modify normal user details and roles. Admin user cannot modify details of other admin users and owner.</p> </li> <li> <p>Deactivate normal Users: Admin users can deactivate normal users. </p> </li> </ol>"},{"location":"links/account_management/#normal-user","title":"Normal User","text":"<p>Normal organisation users have the lower level of authority and can not perform any administrative actions. They can only change thier own details.</p>"},{"location":"links/account_management/#changing-the-ownership-of-the-organization","title":"Changing the ownership of the organization","text":"<p>A current owner can assign another user of the organisation as a owner. This can either be done by the Administrative user of Embever on the request from the owner of the organisation or by the owner user of the organisation him/herself. The following steps needs to be carried out to change the owner user of the organisation.</p> <ol> <li>Login to the Embever console as a owner user.</li> <li>On the Manage accounts section of the homepage click on \"Manage your organisation accounts\". You will be  redirected to the page with list of users on your organisation.</li> <li>If there are not any users besides you click on \"Create New Account\" and create a user to whom you want to transfer the ownership to.</li> <li>On, the users list, click on the \"Edit\" button for the specific user. Now you will see the Update Account form with the user details.</li> <li>Go to Role input and select \"Owner\". Make sure the user you are transferring the ownership is activated before you change the role to Owner.</li> <li>The user that you changed the owner role will receive an email with the ownership transfer request. The email contains a secure link to accept or decline the request. This link is valid for 7 days only. If the link is expired you have to reinitiate the process.</li> <li>When the user accepts the ownership transfer request. The designated user role will be changed to the owner and your role will be changed to a normal user.</li> </ol>"},{"location":"links/account_management/#update-your-own-account-details","title":"Update your own Account Details","text":"<p>As a user you can update your account details like To change your account details follow the following steps</p> <ol> <li>Login to the console.</li> <li>Click on the account icon on the top right part of the menu. A form with your details will open.</li> <li>Edit your details and click submit. If the details are upadated successfully you will see a success message on the top of the form.</li> </ol>"},{"location":"links/account_management/#otp-login","title":"OTP Login","text":"<p>OTP stands for one time password. When OTP is enabled for your account, embever console sends an email to your account email with a token. This token should be entered when you login else you are not able to log in to the console. This is one of the ways to make check if the person trying to log in is legit one. </p> <p>Recommendation</p> <p>OTP is used for the tow factor authorization and turning this on always is highly recommended to secure your account from different attacks.</p>"},{"location":"links/account_management/#activate-otp","title":"Activate OTP","text":"<p>To enable  OTP for your account follow the following steps.</p> <ol> <li>Login to the console.</li> <li>Click on the account icon on the top right part of the menu. A form with your details will open.</li> <li>On the OTP input set the checkbox to checked to enable OTP for your account and click submit.</li> <li>You will receive an email with verification link to verify the OTP along with the verification code.</li> <li>Click on the verification link and enter the verification code to verify.</li> <li>Upon successful verification you will again receive an email notification that OTP login has been activated and verified.</li> </ol>"},{"location":"links/account_management/#deactivate-otp","title":"Deactivate OTP","text":"<p>To enable disable OTP for your account follow the following steps.</p> <ol> <li>Login to the console.</li> <li>Click on the account icon on the top right part of the menu. A form with your details will open.</li> <li>On the OTP input uncheck the checkbox to disable OTP for your account and click submit.</li> <li>Upon successful update , you will receive an email that your OTP login has been deactivated.</li> </ol>"},{"location":"links/account_management/#deactivate-an-account","title":"Deactivate an Account","text":"<p>To deactivae an accont follow the following steps</p> <ol> <li>Login to the console as owner or admin user.</li> <li>On the 'Manage Accounts' seciton of the homepage click on 'Manage your organisation's Accounts'. This will open a page with list of your organization accounts.</li> <li>Click on the 'Edit' button for the account you want to deactivate. This will open a 'Update Account' form for the selected user account.</li> <li>Uncheck the 'Activated' checkbox on the form an click 'Submit'.</li> <li>Updon successful deactivation you will get the success message and the status of the user account changes from active to inactive.</li> </ol> <p>Note</p> <p>There is no option to delete user accounts from the console. Contact Embever at support@embever.com for account deletion requests.</p>"},{"location":"links/embever_iot_core/","title":"Embever IoT Core","text":"<p>Embever IoT Core is the managed service hosted in the cloud that acts as the hub for communication between your devices and your IoT Applications. You can also integrate Embever IoT Core with other external services to build end to end soulutions. Embever IoT Core provides an API and console to manage and interact with different resources in Embever IoT Core.</p>"},{"location":"links/embever_iot_core/#creating-embever-iot-core-account","title":"Creating Embever IoT Core Account","text":"<p>It's important to note that there is no provision for public signup for Embever IoT Core. An Administrative user of Embever creates an account for an organisation on request and creates an administrative user account for the organisation. If your organisation already has an account in Embever IoT Core, please ask the administrative user of your organisation to create an account for you.</p> <p>If you are administrative user of an organisation and looking to manage multiple accounts plese refer to Account Management in Embever IoT Core</p> <p>After an account for an individual user is created successfully ,an activation email is sent to the email of the user. You can simply visit the activation link to setup your account. After successfully setting up your account you should be abe to login to the Embever console under https://console.embever.com and browsable api under https://api.embever.com/.</p> <p>Please contact us for any necessary support.</p>"},{"location":"links/esp-client/","title":"Embever Serial Protocol Client Application","text":""},{"location":"links/iot_core_browsable_api/","title":"Embever IoT Core Browsable API","text":""},{"location":"links/prerequisites/","title":"Prerequisites","text":"<ul> <li>Make sure you have an Embever IoT Core account before you begin. see Creating Embever IoT Core Account</li> <li>System on Chip supported by {{ platform }} with SIM card provided by Embever. Currently {{ platform }} supports nRF9160 only. You will need a SIM card in the form of e-SIM or simply an external sim provided by Embever to connect to the Embever IoT Core Cloud services. The easiest way to get started is to get Cloud as a Module Development Kit from here which comes up with the supported SoC, embeded sim card and extra pheripherials. Alternatively you can use Development kit like nRF9160 DK.</li> <li>Visual Studio code installed in your development machine.</li> </ul>"},{"location":"references/rest_api/","title":"Embever IoT Core REST API","text":""},{"location":"tutorials/","title":"Index","text":"<ul> <li>Quick Steps for using embever API</li> <li>Setting Up the CaaM Application Framework Development Environment</li> </ul>"},{"location":"tutorials/getting_started_with_api/","title":"Getting started with api","text":""},{"location":"tutorials/getting_started_with_api/#getting-started-with-the-api","title":"Getting Started with the API","text":""},{"location":"tutorials/getting_started_with_api/#getting-an-access-token","title":"Getting an access token","text":"<p>The API uses JWT tokens to authorize requests to resources. To obtain an access toke an application token is necessary. To create an application token, use the tokens endpoint in the Embever Cloud Browsable API and make a POST request with an alias.</p> <pre><code>{\n    \"alias\": \"AppTokenHelloWorld\"\n}\n</code></pre> <p>The response should be similar:</p> <pre><code>{\n    \"id\": 45,\n    \"url\": \"https://api.embever.com/v2/tokens/45/\",\n    \"alias\": \"AppTokenHelloWorld\",\n    \"expiry_date\": null,\n    \"token\": \"eyJ0eXAiOiJKdsdfOiJUBGsMiJ9.eyJhbGlhcyI6IkldfhelsseInVzZXJfaWQiOjE4fQ.MT1Zp2emXHjew8nqYF3CrbjIfk6eqH6zrandtokenBhlpJ9jPlpKChs6lbeybnL1AMgq3R68g\",\n    \"scope\": {\n        \"organisation\": \"b4ask977-05c5-470f-a936-d3340bff\",\n        \"application\": null,\n        \"user\": 36\n    },\n    \"created_at\": \"2022-01-28T08:26:12.892335Z\"\n}\n</code></pre> <p>Note</p> <p>The token is displayed only once. Keep it secure as this is used to get the access and refresh tokens to access personal resources in the Embever IoT Core.</p> <p>Obtaining an access token is now possible by posting an application token to the <code>/authenticate</code> endpoint.</p> <pre><code>curl --location --request POST 'https://api.embever.com/v2/authenticate/' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"application_token\" : \"eyJ0eXAiOiJKdsdfOiJUBGsMiJ9.eyJhbGlhcyI6IkldfhelsseInVzZXJfaWQiOjE4fQ.MT1Zp2emXHjew8nqYF3CrbjIfk6eqH6zrandtokenBhlpJ9jPlpKChs6lbeybnL1AMgq3R68g\"\n}'\n\n{\n    \"refresh\": \"eyJ0eXAiOiJKdsdfOiJUBGsMiJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVz2QwZDQ1N2M2NDBhYWIzNzk2NmI2ZmYwMjBmMTQiLCJ1c2VyX2lkIjoxOH0.lC-3jlgeOBYuk5Ul3zTqRFpVA1SEouJ3sHKkSH5Q\",\n    \"access\": \"eyJ0eXAiOiJKdsdfOiJUBGsMiJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNjQzMA0ZTgyODA5YmI1MzEwZmQ3MzczNSIsInVzZXJfaWQi.dDjwoOpOpxvysqw1-Iotthq9Zrpx1BQQxBzk2Z7h\"\n}\n</code></pre> <p>Access token can now be passed to the Authorization header to access the resources in the API.</p> <p>To confirm the above steps, let\\'s try to get a devices by using the <code>curl</code> utility.</p> <pre><code>curl --location --request GET 'https://api.embever.com/v2/devices/' \\\n--header 'Authorization: Bearer eyJ0eXAiOiJKdsdfOiJUBGsMiJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNjQzMA0ZTgyODA5YmI1MzEwZmQ3MzczNSIsInVzZXJfaWQi.dDjwoOpOpxvysqw1-Iotthq9Zrpx1BQQxBzk2Z7h'\n\n[\n    {\n    \"url\": \"https://api.embever.com/v2/devices/EzJei1BX/\",\n    \"id\": \"EzJei1BX\",\n    \"name\": \"HelloWorldDevice\",\n    \"activated\": true,\n    \"application\": null,\n    \"type\": \"other\",\n    \"webhooks\": null,\n    \"meta\": null,\n    \"sim\": \"123456789019876\",\n    \"created_at\": \"2022-01-25T15:58:37.293802Z\"\n    }\n]\n</code></pre> <p>Accessing other resources in the API using the access token is also possible.</p>"},{"location":"tutorials/getting_started_with_api/#creating-an-action","title":"Creating an action","text":"<p>The following example shows how to create actions in the API.</p> <pre><code>curl --location --request POST 'https://api.embever.com/v2/actions/' \\\n--header 'Authorization: Bearer eyJ0eXAiOiJKdsdfOiJUBGsMiJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNjQzMA0ZTgyODA5YmI1MzEwZmQ3MzczNSIsInVzZXJfaWQi.dDjwoOpOpxvysqw1-Iotthq9Zrpx1BQQxBzk2Z7h'\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"device\": {\n        \"id\": \"EzJei1BX\"\n    },\n    \"type\": \"setLED\",\n    \"payload\": {\n        \"LED\": \"on\"\n    }\n}'\n\n{\n    \"url\": \"https://api.embever.com/v2/actions/1003691/\",\n    \"id\": 1003691,\n    \"device\": {\n        \"id\": \"EzJei1BX\",\n        \"name\": \"HelloWorldDevice\"\n    },\n    \"type\": \"setLED\",\n    \"payload\": {\n        \"LED\": \"on\"\n    },\n    \"status\": {},\n    \"webhooks\": null,\n    \"service_level\": 0,\n    \"cancelled\": false,\n    \"finished\": false,\n    \"result\": null,\n    \"created_at\": \"2022-01-28T09:32:25.379189Z\",\n    \"result_code\": null,\n    \"expiry_date\": null,\n    \"expired\": false\n}\n</code></pre>"},{"location":"tutorials/getting_started_with_api/#getting-events-from-the-device","title":"Getting events from the Device","text":"<p>The following example shows how to get events from the API.</p> <pre><code>curl --location --request GET 'https://api.embever.com/v2/devices/EzJb1BX/events/' \\\n--header 'Authorization: Bearer eyJ0eXAiOiJKdsdfOiJUBGsMiJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNjQzMA0ZTgyODA5YmI1MzEwZmQ3MzczNSIsInVzZXJfaWQi.dDjwoOpOpxvysqw1-Iotthq9Zrpx1BQQxBzk2Z7h'\n\n[\n    {\n        \"url\": \"https://api.embever.com/v2/events/70664807/\",\n        \"id\": 70664807,\n        \"device\": \"EzJei1BX\",\n        \"sim\": \"123456789019876\",\n        \"type\": \"wakeUp\",\n        \"payload\": {\n            \"lat\": 525841746,\n            \"lon\": 122812903\n        },\n        \"created_at\": \"2022-01-13T16:09:21.991434Z\"\n    },\n    ...\n]\n</code></pre> <p>For more details please visit the Embever core API documentations.</p>"},{"location":"tutorials/console/account_mgmt/","title":"Account mgmt","text":""},{"location":"tutorials/console/account_mgmt/#activate-your-embever-iot-core-account","title":"Activate your Embever IoT Core Account","text":"<p>It's important to note that there is no provision for public signup within the Embever Console. Account creation is exclusively managed by administrative users of Embever and owners and admins of the organisation, ensuring controlled access to the platform's resources. Below are the steps involved in this process. If your organisation already has an Embever IoT Core Accound, please ask the administrative user for your organisation to create an account for you. You will receive and activation email. Please visit the activaiton link to setup your account. After successfully setting up your account you should be abe to login to the Embever console under https://console.embever.com and browsable api under https://api.embever.com/.</p>"},{"location":"tutorials/data_transfer/telemetry/","title":"Send telemetry Data from Device to the cloud","text":""},{"location":"tutorials/data_transfer/telemetry/#upload-file-from-the-device","title":"Upload File from the Device","text":""},{"location":"tutorials/data_transfer/telemetry/#download-file-from-the-device","title":"Download File from the Device","text":""},{"location":"tutorials/embedded/uaf/uaf_env_setup_guide/","title":"Setting up the CaaM Application Framework development environment","text":"<p>This tutorial will guide trough the process to set up the development environment to get started with the CaaM Application Framework.</p>"},{"location":"tutorials/embedded/uaf/uaf_env_setup_guide/#1-step-setting-up-the-nordic-nrf-connect-sdk","title":"1. Step: Setting up the Nordic nRF Connect SDK","text":"<p>To set up the nRF Connect SDK, follow the official guide written by Nordic Semiconductor team here. Choose the nRF Connect SDK version 2.2.0 from the Toolchain Manager.</p> <p>Note</p> <p>If this version is not listed on the Toolchain Manager, change the setting of the application based on the screenshot below.</p> <p></p> <p>If the mentioned SDK version is not listed, turn off the \u201cShow only 3 newest minor version\u201d option on the Toolchain Manager settings page.</p> <p>To exploit all the possibilities of the development experience, review this page as well. To verify the local development environment, try to compile and upload one of the nordic sample application.</p> <p></p>"},{"location":"tutorials/embedded/uaf/uaf_env_setup_guide/#2-step-get-a-local-copy-of-the-embever-user-application-framework-template","title":"2. Step: Get a local copy of the Embever User Application Framework Template","text":"<p>To get a local copy of the of the CaaM User Application Framework template, clone the repository listed below, or use the distributed archive.</p> <p>Note</p> <p>Note, this repository contain submodules which are necessary for its operation.</p> <p>Use the following command to make sure that the submodules are downloaded as well.*</p> <p><code>git clone --recurse-submodules git@github.com:Embever/ebv_UAF_template.git</code></p> <p></p>"},{"location":"tutorials/embedded/uaf/uaf_env_setup_guide/#3-step-working-with-the-uaf-template","title":"3. Step: Working with the UAF template","text":"<p>To start working with the UAF template, open the nRF Connect SDK IDE, which is the Visual Studio Code with the Nordic nRF Connect SDK plugin. To do that, click on the \"Open VS Code\" button in the nRF Connect Desktop Toolchain Manager. Importing the UAF template is as simple as clicking to the Open Application button after selecting the nRF Connect extension tab on the sidebar in VS Code.</p> <p></p> <p>Opening the UAF template as and existing application by the Open Application button As the application opened successfully, the next step is to define a build target</p> <p></p> <p></p> <p>Build configuration successfully defined, SDK and toolchain version set to 2.2.0</p>"},{"location":"tutorials/embedded/uaf/uaf_env_setup_guide/#step-5-crypto-keys-for-binary-encryption","title":"Step 5: Crypto keys for binary encryption","text":"<p>To embed secure firmware update into the deployment process, the firmware binary has to be signed with a unique key. Ignoring this option and using the default keys of the SDK is not forbidden for internal development, but as soon as the firmware pass the development stage, it is recommended to use a custom keys to maintain security.</p> <p>Note</p> <p>To use the default keys to sign the firmware binaries, remove ( or make the line begin with the <code>#</code> sign to disable it) the following line in the <code>mcuboot.conf</code> file.</p> <pre><code>CONFIG_BOOT_SIGNATURE_KEY_FILE=\"fota-keys/nRF9160/dev/mcuboot-ec-p256.pem\"\n</code></pre> <p>To generate a custom signing keys, follow this guide written by the Nordic Semiconductor team. The newly generated keys can be places to any location and they can be referenced with they absolute path. Using a relative path is also possible ( like the default value of the <code>CONFIG_BOOT_SIGNATURE_KEY_FILE</code> ). In this case the base directory of this relative path is the following location:</p> <p><code>&lt;nrf_sdk_base&gt;/&lt;version_number&gt;/bootloader/mcuboot</code></p> <p>As an example, the absolute location of the signing key is : <code>/opt/nordic/ncs/v2.2.0/bootloader/mcuboot/fota-keys/nRF9160/dev/mcuboot-ec-p256.pem</code></p>"},{"location":"tutorials/embedded/uaf/uaf_env_setup_guide/#step-6-build-and-flash","title":"Step 6: Build and Flash","text":"<p>To build the application, use the Build Configuration button or use one of the built-in build tasks of the nRF Connect extension.</p> <p></p>"}]}